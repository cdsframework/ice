/**
 * Copyright (C) 2019 New York City Department of Health and Mental Hygiene, Bureau of Immunization
 * Contributions by HLN Consulting, LLC
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU
 * Lesser General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. You should have received a copy of the GNU Lesser
 * General Public License along with this program. If not, see <http://www.gnu.org/licenses/> for more
 * details.
 *
 * The above-named contributors (HLN Consulting, LLC) are also licensed by the New York City
 * Department of Health and Mental Hygiene, Bureau of Immunization to have (without restriction,
 * limitation, and warranty) complete irrevocable access and rights to this project.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; THE
 *
 * SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
 * BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, IF ANY, OR DEVELOPERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES, OR OTHER LIABILITY OF ANY KIND, ARISING FROM, OUT OF, OR IN CONNECTION WITH
 * THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information about this software, see http://www.hln.com/ice or send
 * correspondence to ice@hln.com.
 */ 
 
package org.cdsframework.ice.v1_1_0

import java.util.ArrayList
import java.util.Collection
import java.util.Date
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import java.util.HashSet
import java.util.HashMap
import org.drools.spi.KnowledgeHelper
import org.opencds.vmr.v1_0.internal.AdministrableSubstance
import org.opencds.vmr.v1_0.internal.ClinicalStatement
import org.opencds.vmr.v1_0.internal.ClinicalStatementRelationship
import org.opencds.vmr.v1_0.internal.EntityBase
import org.opencds.vmr.v1_0.internal.EvaluatedPerson
import org.opencds.vmr.v1_0.internal.EvalTime
import org.opencds.vmr.v1_0.internal.ObservationResult
import org.opencds.vmr.v1_0.internal.ObservationValue
import org.opencds.vmr.v1_0.internal.SubstanceAdministrationEvent
import org.opencds.vmr.v1_0.internal.SubstanceAdministrationProposal
import org.opencds.vmr.v1_0.internal.concepts.ImmunizationConcept
import org.opencds.vmr.v1_0.internal.concepts.ObservationCodedValueConcept
import org.opencds.vmr.v1_0.internal.concepts.ObservationFocusConcept
import org.opencds.vmr.v1_0.internal.datatypes.BL
import org.opencds.vmr.v1_0.internal.datatypes.CD
import org.opencds.vmr.v1_0.internal.datatypes.INT
import org.opencds.vmr.v1_0.internal.datatypes.IVLDate
import org.cdsframework.ice.service.DateFactType
import org.cdsframework.ice.service.DiseaseImmunity
import org.cdsframework.ice.service.DoseRule
import org.cdsframework.ice.service.DoseStatus
import org.cdsframework.ice.service.ICEFactTypeFinding
import org.cdsframework.ice.service.LiveVirusFact
import org.cdsframework.ice.service.InconsistentConfigurationException
import org.cdsframework.ice.service.ICELogicHelper
import org.cdsframework.ice.service.PayloadHelper
import org.cdsframework.ice.service.Recommendation
import org.cdsframework.ice.service.RecommendationStatus
import org.cdsframework.ice.service.Schedule
import org.cdsframework.ice.service.Season
import org.cdsframework.ice.service.SeriesRules
import org.cdsframework.ice.service.TargetDose
import org.cdsframework.ice.service.TargetDoseInitializationTracker
import org.cdsframework.ice.service.TargetSeasons
import org.cdsframework.ice.service.TargetSeries
import org.cdsframework.ice.service.TargetSeriesSelection
import org.cdsframework.ice.service.TargetSeriesSelection.SeriesSelectionStatus
import org.cdsframework.ice.supportingdata.BaseDataEvaluationReason
import org.cdsframework.ice.supportingdata.BaseDataRecommendationReason
import org.cdsframework.ice.supportingdatatmp.SupportedFactConcept
import org.cdsframework.ice.util.TimePeriod
import org.cdsframework.ice.util.TimePeriod.DurationType
import org.cdsframework.ice.service.Vaccine
import org.cdsframework.ice.service.VaccineComponent


// OpenCDS specific
global java.lang.String clientLanguage
global java.lang.String clientTimeZoneOffset
global java.lang.String focalPersonId
global java.util.Date evalTime
global java.util.HashSet<String> assertions
global java.util.HashMap<String,Object> namedObjects

// ICE specific
global java.util.Date patientAgeTimeOfInterest
global org.cdsframework.ice.service.Schedule schedule
global java.lang.Boolean outputNumberOfDosesRemaining
global java.lang.Boolean outputEarliestOverdueDates

// global org.drools.runtime.KnowledgeContext kcontext


/*****************************************************************************************************************************************************************************/
// 															Initialize Immunization Schedule and other Reference Data
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData.Initialize Immunization Schedule and Supporting Data" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
   	when
		eval(patientAgeTimeOfInterest == null)
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", evalTime);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initialized patientAgeTimeOfInterest" + evalTime);		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData.Initialize Focal Person Id" ruleflow-group "ImmunizationReferenceData"
	no-loop true
	dialect "mvel"
	salience 10
   	when
   		not LiveVirusFact()
   		not TargetSeasons()
		$evaluatedPerson : EvaluatedPerson(isFocalPerson() == true)
		eval(focalPersonId == null || focalPersonId.length() == 0)
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("focalPersonId", $evaluatedPerson.getId());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initialized Focal Person ID" + $evaluatedPerson.getId());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Live Virus Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not (LiveVirusFact())
	then
		String _RULENAME = kcontext.rule.name;		
		LiveVirusFact lvd = new LiveVirusFact();
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Live Virus Fact Object Initialized");
		insert(lvd);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Select Adjuvant Product Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL")
	then
		String _RULENAME = kcontext.rule.name;		
		DateFactType dft = new DateFactType("SELECT_ADJUVANT_PRODUCT_INTERVAL");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Select Adjuvant Product Interval Fact Object Initialized");
		insert(dft);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Target Seasons Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not (TargetSeasons())
	then
		String _RULENAME = kcontext.rule.name;		
		TargetSeasons tseasons = new TargetSeasons(evalTime);
		insert(tseasons);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeasons Fact Object Initialized");
end


///////// ***
// General Design rule... Do not Edit
/////////
rule "InitializeReferenceData: Output Number of Doses Remaining?" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
when
	not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue)
	eval(outputNumberOfDosesRemaining != null && outputNumberOfDosesRemaining.booleanValue() == true)
then
	String _RULENAME = kcontext.rule.name;
	ICEFactTypeFinding iftf = new ICEFactTypeFinding(SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue);
	insert(iftf);
	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Output number of doses remaining? Initialized");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Load SeriesRules and TargetDoseInitializationTracker on to Fact List" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "java"
	salience 20
	when
		not SeriesRules()
	then
		String _RULENAME = drools.getRule().getName();
		List<SeriesRules> allCandidates = schedule.getCandidateSeries();
		if (allCandidates != null) {
			Iterator<SeriesRules> iter = allCandidates.iterator();
			if (iter == null) {
				ICELogicHelper.logDRLDebugMessage(_RULENAME, "iter is null");
			}
			while(iter.hasNext()) {
				SeriesRules s = iter.next();
				if (s == null) {
					ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesRules S == null");
				}
				insert(s);
				ICELogicHelper.logDRLDebugMessage(_RULENAME, "Loaded SeriesRules object on the fact list: " + s.getSeriesName());
			}
		}
		TargetDoseInitializationTracker tdit = new TargetDoseInitializationTracker();
		insert(tdit);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Eval Time provided by OpenCDS: " + evalTime.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Insert SeriesRules Seasons into TargetSeasons" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 20
	when
		$tseasons : TargetSeasons()
		$sr : SeriesRules(seasons.size() > 0)
		$season : Season() from $sr.seasons
		not (Season(this == $season))
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.addTargetSeason($season);
		insert($season);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initial season inserted into working memory; TargetSeasons updated with Season: " + $season.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Update Seasons in Working Memory with Information from TargetSeasons" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 10
	no-loop true
	when
		$season : Season(isDefaultSeason() == false)
		$tseasons : TargetSeasons(containsTargetSeason($season))
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.updateFullySpecifiedSeasonWithOffSeasonDates($season);
		update($season);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Season **updated** in working memory: " + $season.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Update Fully-Specified Seasons in Series with Information from TargetSeasons" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 5
	no-loop true
	when
		$tseasons : TargetSeasons()
		$sr : SeriesRules(seasons.size() > 0)
		$season : Season(isDefaultSeason() == false) from $sr.seasons
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.updateFullySpecifiedSeasonWithOffSeasonDates($season);
		update($sr);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesRules Season **updated**: " + $season.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Log TargetSeasons Tracked for this Request" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience -1
	when
		$tseasons : TargetSeasons()
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeasons: " + $tseasons.toString());
end

		
/*****************************************************************************************************************************************************************************/
// 															Identify Candidate Series Ruleflow Group - TargetSeries Initialization
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries Custom Rules Invocation" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 110
	when
		$s : SeriesRules()
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoke Custom CandidateSeriesIdentificationRule for SeriesRules: " + $s.getSeriesName());
		setFocus("customCandidateSeriesIdentificationRule");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries for non-seasonal vaccine groups" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 100
	when
		$s : SeriesRules(seasons == null || seasons.isEmpty())
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries initialized: " + ts.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries for *Current* Season with Fully-Specified Season Parameters (if defined)" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 100
	when
		$s : SeriesRules(seasons != null, seasons.size() > 0, $vg : vaccineGroup)  
		$season : Season(isDefaultSeason() == false, isDefinedBySeriesTableRules() == true, dateIsApplicableToSeason(evalTime)) from $s.seasons
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason.isDefaultSeason() == false, targetSeason == $season))
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $season);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize *Current* Season TargetSeries with Default Season Parameters if Current Not Defined for the Vaccine Group" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 90
	when
		$s : SeriesRules($vg : vaccineGroup, seasons != null, seasons.size() > 0)
		$season : Season(isDefaultSeason() == true, dateIsApplicableToSeason(evalTime)) from $s.seasons
		not (Season(isDefaultSeason() == false, vaccineGroup == $vg, dateIsApplicableToSeason(evalTime)))  
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason == $season))
		$tseasons : TargetSeasons()
	then
		String _RULENAME = kcontext.rule.name;
		Season fullySpecified = Season.constructFullySpecifiedSeasonFromDefaultSeasonAndDate($season, evalTime);
		$tseasons.addTargetSeason(fullySpecified);
		TargetSeries ts = new TargetSeries($s, schedule, fullySpecified);
		$s.addFullySpecifiedSeason(fullySpecified);		
		insert(ts);
		insert(fullySpecified);
		update($s);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Updated* TargetSeasons: " + $tseasons.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize *Past* Season TargetSeries when Shots Administered with Fully-Specified Season Parameters if Fully-Specified Season Parameters Defined for the Season" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 80
	when
		ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$s : SeriesRules($vg : vaccineGroup, seasons.size() > 0)
		$season : Season(isDefaultSeason() == false, isDefinedBySeriesTableRules() == true, $season.dateIsApplicableToSeason($shotDate)) from $s.seasons
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason == $season))
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)		
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $season);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize *Past* Season TargetSeries when Shots Administered with Default Season Parameters if No Fully-Specified Season Parameters Defined for the Season" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 70
	when
		ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$s : SeriesRules($vg : vaccineGroup, seasons.size() > 0)
		$season : Season(isDefaultSeason() == true) from $s.seasons
		not Season(isDefaultSeason() == false, vaccineGroup == $vg, dateIsApplicableToSeason($shotDate))
		// Note: for TargetSeries, do not match on series name when there is a default seasons because we do not want a TargetSeries created for the default season if another TargetSeries
		// already handles that season
		not (TargetSeries(targetSeason != null, targetSeason == Season.constructFullySpecifiedSeasonFromDefaultSeasonAndDate($season, $shotDate))) 
		$tseasons : TargetSeasons()
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)		
	then
		String _RULENAME = kcontext.rule.name;
		// Create a fully-specified season for this specific year using the default month and day
		Season fullySpecified = Season.constructFullySpecifiedSeasonFromDefaultSeasonAndDate($season, $shotDate);
		$tseasons.addTargetSeason(fullySpecified);
		TargetSeries ts = new TargetSeries($s, schedule, fullySpecified);
		$s.addFullySpecifiedSeason(fullySpecified);
		insert(ts);
		insert(fullySpecified);
		update($s);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Updated* TargetSeasons: " + $tseasons.toString());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries when Shots Administered when One and Only One Season for Vaccine Group exists and no matching Fully-Specified Season Parameters or Default Season Defined for the Season" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 70
	when
		ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$s : SeriesRules($vg : vaccineGroup, seasons.size() > 0)
		not Season(isDefaultSeason() == true, vaccineGroup == $vg)
		// Condition: If there is only one season and above TS does not match it, then we can conclude that there is no seasonal TS that will match
		accumulate($accSeason : Season(vaccineGroup == $vg); $count : count($accSeason); $count == 1)		
		$season : Season(isDefaultSeason() == false, vaccineGroup == $vg, dateIsApplicableToSeason($shotDate) == false)
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason == $season))
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)		
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $season);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());		
end


/*****************************************************************************************************************************************************************************/
// 															Identify Candidate Doses Ruleflow Group - TargetDoses Initialization
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateDosesIdentification: Initialize TargetDose Custom Rules Invocation" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 110
	when
		$i : ImmunizationConcept($ctid : conceptTargetId)
		$sae : SubstanceAdministrationEvent(id == $ctid)
	then
		String _RULENAME = kcontext.rule.name;
		setFocus("customCandidateDosesIdentificationRule");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoke Custom CandidateSeriesIdentificationRule for SubstanceAdministrationEvent: " + $sae.toString());
end


///////// ***
// General Design rule... Do not Edit
// For each series that was identified as relevant, initialize each TargetSeries with TargetDoses. TargetDoses are created/initialized for all
// shots administered where the vaccine is used by the vaccine group, even if the Series itself does not permit that kind of vaccine to be used
// in any of its doses. This is so that shots administered with a vaccine present in the Vaccine Group will still be evaluated with a decision 
// should that TargetSeries be selected from which to forecast.
///////// ***
rule "CandidateDosesIdentification: Initialize TargetDose in *Non-Seasonal* TargetSeries" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 50
	no-loop true
	when
		$i : ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		$sae : SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$ts : TargetSeries($vg : vaccineGroup, targetSeasonExists() == false, $tsid : targetSeriesIdentifier)
		// Condition: the tracking map must either NOT contain a key with this SubstanceAdministrationEvent and this OpenCDS concept, or if it does contain 
		// this SubstanceAdministrationEvent and this OpenCDS concept, that the value of this key is the same as concept code as that of the vaccine group's. 
		// Furthermore, if there exists a vaccine component within this shot administered that has not been initialized in this series for this vaccine group, 
		$tdit : TargetDoseInitializationTracker(shotAdministeredIsEligibleForInclusionInTargetSeries($i, $vg, $sae, $ts, schedule.getVaccineByCdsConceptValue($occ)) == true)
		// Condition: the administered vaccine targets one or more of the diseases handled for this vaccine group
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
	then
		String _RULENAME = kcontext.rule.name;
		Vaccine administeredVaccine = schedule.getVaccineByCdsConceptValue($i.getOpenCdsConceptCode());
		for (TargetDose initializedTargetDose : $tdit.addTargetDoseInitialization(administeredVaccine, $sae, $ts, schedule)) {
			insert(initializedTargetDose);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose initialized in TargetSeries " + $ts.seriesName + " ; vaccine: " + $occ + "; vaccine group " + $vg + "; shotdate " + $shotDate);
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, "completed");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateDosesIdentification: Initialize TargetDose in *Seasonal* TargetSeries" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 50
	no-loop true
	when
		$i : ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		$sae : SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$ts : TargetSeries($vg : vaccineGroup, targetSeason != null && targetSeason.dateIsApplicableToSeason($shotDate), $tsid : targetSeriesIdentifier)
		// Condition: the tracking map must either NOT contain a key with this SubstanceAdministrationEvent and this OpenCDS concept, or if it does contain 
		// this SubstanceAdministrationEvent and this OpenCDS concept, that the value of this key is the same as concept code as that of the vaccine group's. 
		// Furthermore, if there exists a vaccine component within this shot administered that has not been initialized in this series for this vaccine group, 
		$tdit : TargetDoseInitializationTracker(shotAdministeredIsEligibleForInclusionInTargetSeries($i, $vg, $sae, $ts, schedule.getVaccineByCdsConceptValue($occ)) == true)
		// Condition: the administered vaccine targets one or more of the diseases handled for this vaccine group
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
	then
		String _RULENAME = kcontext.rule.name;
		Vaccine administeredVaccine = schedule.getVaccineByCdsConceptValue($i.getOpenCdsConceptCode());
		for (TargetDose initializedTargetDose : $tdit.addTargetDoseInitialization(administeredVaccine, $sae, $ts, schedule)) {
			insert(initializedTargetDose);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose initialized in TargetSeries " + $ts.seriesName + " ; vaccine: " + $occ + "; vaccine group " + $vg + "; shotdate " + $shotDate);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, "completed");	
end

///////// ***
// General Design rule... Do not Edit
// Seasonal TargetDose Outlier Initialization Rule: TargetDose initialization rule for H1N1 or other "seasonal" series that have only one defined season and no default season 
// E.G. - Since there is only one season for H1N1 and no default season, any shots that come in will get associated with the existing TargetSeries even if it falls outside 
// of its season date. NOTE: ICE Schedule validation does not permit multiple seasons in a vaccine group if there is no default season defined.
///////// ***
rule "CandidateDosesIdentification: Initialize Outlier TargetDose into Existing TargetSeries" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 50
	no-loop true
	when
		$i : ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		$sae : SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$ts : TargetSeries($vg : vaccineGroup, targetSeason != null && targetSeason.dateIsApplicableToSeason($shotDate) == false, $tsid : targetSeriesIdentifier)
		// Condition: there is no default season for this vaccine group
		not Season(vaccineGroup == $vg, isDefaultSeason() == true)
		// Condition: If there is only one season and above TS does not match it, then we can conclude that there is no seasonal TS that will match
		accumulate($accSeason : Season(vaccineGroup == $vg); $count : count($accSeason); $count == 1)
		// Condition: the tracking map must either NOT contain a key with this SubstanceAdministrationEvent and this OpenCDS concept, or if it does contain 
		// this SubstanceAdministrationEvent and this OpenCDS concept, that the value of this key is the same as concept code as that of the vaccine group's. 
		// Furthermore, if there exists a vaccine component within this shot administered that has not been initialized in this series for this vaccine group, 
		$tdit : TargetDoseInitializationTracker(shotAdministeredIsEligibleForInclusionInTargetSeries($i, $vg, $sae, $ts, schedule.getVaccineByCdsConceptValue($occ)) == true)
		// Condition: the administered vaccine targets one or more of the diseases handled for this vaccine group
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
	then
		String _RULENAME = kcontext.rule.name;
		Vaccine administeredVaccine = schedule.getVaccineByCdsConceptValue($i.getOpenCdsConceptCode());
		for (TargetDose initializedTargetDose : $tdit.addTargetDoseInitialization(administeredVaccine, $sae, $ts, schedule, true)) {
			insert(initializedTargetDose);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose initialized in TargetSeries " + $ts.seriesName + " ; vaccine: " + $occ + "; vaccine group " + $vg + "; shotdate " + $shotDate);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, "completed; TargetSeries " + $ts);	
end



/*****************************************************************************************************************************************************************************/
// 															Record Disease Immunity
/*****************************************************************************************************************************************************************************/
 
// If the patient has immunity to a disease and it is on or after the immunity date, mark the patient as immune to the disease in the series
rule "DiseaseImmunityRecord.MarkImmuneToDiseaseIfOnOrAfterImmunityDate" ruleflow-group "DiseaseImmunityRecord"
	dialect "mvel"
	no-loop
	when
		$di : DiseaseImmunity($disease : disease, $immunityDate : dateOfImmunity <= evalTime)
		$targetSeries : TargetSeries($disease memberOf diseasesSupportedByThisSeries, targetSeason == null || targetSeason != null && targetSeason.fullySpecifiedSeasonStartDate.toDate() <= evalTime)
	then
		String _RULENAME = kcontext.rule.name;
		$targetSeries.markImmunityToSpecifiedDisease($disease, $immunityDate);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "for disease " + $disease + ", immunity date " + $immunityDate + " in TargetSeries " + $targetSeries.getSeriesName());
		update($targetSeries);
end



/*****************************************************************************************************************************************************************************/
// 															Evaluation of doses
/*****************************************************************************************************************************************************************************/


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateSeriesWhenNoTargetDosesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$ts : TargetSeries(numberOfShotsAdministeredInSeries == 0, isHistoryEvaluationInitiated() == false)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $ts);
		setFocus("customEvaluationRule");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setNextTargetDoseNonNOSInNonSeasonalSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == false)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)	
		$ts : TargetSeries(targetSeason == null, this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		$ts.setHistoryEvaluationInitiated(true);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setNextTargetDoseNonNOSInSeasonalSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == false)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		$ts : TargetSeries(targetSeason != null, this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		$ts.setHistoryEvaluationInitiated(true);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit - for same day shots, only select NOS shot for evaluation after all other non-NOS shots have been evaluated for this series
///////// ***
rule "HistoryEvaluation.setNextTargetDoseNOSInNonSeasonalSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == true)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, uniqueId != $td.uniqueId, administrationDate == $td.administrationDate, vaccineComponent.isUnspecifiedFormulation() == false)
		$ts : TargetSeries(targetSeason == null, this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		$ts.setHistoryEvaluationInitiated(true);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit - for same day shots, only select NOS shot for evaluation after all other non-NOS shots have been evaluated for this series
///////// ***
rule "HistoryEvaluation.setNextTargetDoseNOSInSeasonalSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == true)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, uniqueId != $td.uniqueId, administrationDate == $td.administrationDate, vaccineComponent.isUnspecifiedFormulation() == false)
		$ts : TargetSeries(targetSeason != null, this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		$ts.setHistoryEvaluationInitiated(true);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end



///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setIsPrimarySeriesShotToTrueIfSeriesIsNotComplete" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS, isPrimarySeriesShot() == false)
		$ts : TargetSeries(containsTargetDose($td), isSeriesComplete() == false)
		$tdsEvaluated : List() from accumulate($tdacc : TargetDose(associatedTargetSeries == $td.associatedTargetSeries, hasBeenEvaluated == true), collectList($tdacc))	
	then
		String _RULENAME = kcontext.rule.name;
		int tddosenumber = $ts.determineDoseNumberInSeries();
		int tdshotnumber = $tdsEvaluated.size()+1;
		modify($td) {
			setStatus(DoseStatus.EVALUATION_IN_PROCESS),
			setIsPrimarySeriesShot(true),
			setDoseNumberInSeries(tddosenumber),
			setAdministeredShotNumberInSeries(tdshotnumber);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("preEvaluationValidation");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setIsPrimarySeriesShotToFalseIfSeriesIsComplete" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS, isPrimarySeriesShot() == true)
		$ts : TargetSeries(containsTargetDose($td), isSeriesComplete() == true)
		$tdsEvaluated : List() from accumulate($tdacc : TargetDose(associatedTargetSeries == $td.associatedTargetSeries, hasBeenEvaluated == true), collectList($tdacc))
	then
		String _RULENAME = kcontext.rule.name;
		int tddosenumber = $ts.determineDoseNumberInSeries();
		int tdshotnumber = $tdsEvaluated.size()+1;
		modify($td) {
			setStatus(DoseStatus.EVALUATION_IN_PROCESS),
			setIsPrimarySeriesShot(false),
			setDoseNumberInSeries(tddosenumber),
			setAdministeredShotNumberInSeries(tdshotnumber);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("preEvaluationValidation");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.primarySeriesShotAlreadyFalseAndSeriesIsComplete" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS, isPrimarySeriesShot() == false)
		$ts : TargetSeries(containsTargetDose($td), isSeriesComplete() == true)
		$tdsEvaluated : List() from accumulate($tdacc : TargetDose(associatedTargetSeries == $td.associatedTargetSeries, hasBeenEvaluated == true), collectList($tdacc))
	then
		String _RULENAME = kcontext.rule.name;
		int tddosenumber = $ts.determineDoseNumberInSeries();
		int tdshotnumber = $tdsEvaluated.size()+1;
		modify($td) {
			setStatus(DoseStatus.EVALUATION_IN_PROCESS),
			setDoseNumberInSeries(tddosenumber),
			setAdministeredShotNumberInSeries(tdshotnumber);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("preEvaluationValidation");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.primarySeriesShotAlreadyTrueAndSeriesNotComplete" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS, isPrimarySeriesShot() == true)
		$ts : TargetSeries(containsTargetDose($td), isSeriesComplete() == false)
		$tdsEvaluated : List() from accumulate($tdacc : TargetDose(associatedTargetSeries == $td.associatedTargetSeries, hasBeenEvaluated == true), collectList($tdacc))
	then
		String _RULENAME = kcontext.rule.name;
		int tddosenumber = $ts.determineDoseNumberInSeries();
		int tdshotnumber = $tdsEvaluated.size()+1;
		modify($td) {
			setStatus(DoseStatus.EVALUATION_IN_PROCESS),
			setDoseNumberInSeries(tddosenumber),
			setAdministeredShotNumberInSeries(tdshotnumber);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("preEvaluationValidation");
end


///////// ***
// General Design and Supplemental Series Table rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If the vaccine is administered after the immunity date recorded for *all* diseases targeted by the vaccine, mark the shot ACCEPTED. 
// Mark the status of the shot as EVALUATION_COMPLETE, to prevent other rules from overriding this ACCEPTED decision
//////// ***
rule "HistoryEvaluation: Check if Shot should be marked Accepted and Series Complete if Administered On or After Immunity Date" ruleflow-group "HistoryEvaluation"
	dialect "java"
	agenda-group "preEvaluationValidation"
	when
		$targetDose : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $diseasesTargetedByThisDose : vaccineComponent.allDiseasesTargetedForImmunity, $doseAdministrationDate : administrationDate)
		$targetSeries : TargetSeries(containsTargetDose($targetDose))
		do[invokeCustomEvaluationRules]
		$diseaseImmunityList : List(size == $diseasesTargetedByThisDose.size()) from 
			accumulate($di : DiseaseImmunity($d : disease, dateOfImmunity <= $doseAdministrationDate, $r : immunityReason, disease memberOf $diseasesTargetedByThisDose), collectList($di))
	then
		Iterator dilIter = $diseaseImmunityList.iterator();
		while (dilIter.hasNext()) {
			DiseaseImmunity diConsequence = (DiseaseImmunity) dilIter.next();
			$targetDose.addAcceptedReason(diConsequence.getEvaluationReasonResult());				
		}
		modify ($targetDose) { setStatus(DoseStatus.EVALUATION_COMPLETE) } ///// Note for docs: marking this dose valid, so we mark evaluation complete override all other "negative check" rules
		ICELogicHelper.logDRLDebugMessage(drools.getRule().getName(), "Marking Evaluation Complete for TargetDose " + $targetDose.toString() + " in TargetSeries " + $targetSeries .getSeriesName());
	then[invokeCustomEvaluationRules]
		ICELogicHelper.logDRLDebugMessage(drools.getRule().getName(), "Check complete.");
		drools.setFocus("makeNoteOfDuplicateShotSameDayIfAny");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "Duplicate Shot/Same Day (Abstract): 2 shots administered on the same day" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	agenda-group "makeNoteOfDuplicateShotSameDayIfAny"
	no-loop true
	when
		$td: TargetDose(isPreEvaluationCheckCompleted() == false, status == DoseStatus.EVALUATION_IN_PROCESS, $administrationDate : administrationDate, $tdAdministeredShotNumber : administeredShotNumberInSeries, 
			$doseNumber : doseNumberInSeries)
		$tdprev : TargetDose(administrationDate == $administrationDate, administeredShotNumberInSeries == $tdAdministeredShotNumber-1, $tdprevDoseNumber: doseNumberInSeries, $tdprevDoseNumber <= $doseNumber)
		$targetSeries : TargetSeries(containsTargetDose($td), containsTargetDose($tdprev))
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $targetSeries);
end


///////// ***
// General Design rule... Do not Edit
// If this shot is a duplicate shot/same day shot as another shot in the series, mark its dose number the same as the previous shot (only one of the duplicate shot can be a valid dose)
///////// ***
rule "Duplicate Shot/Same Day: If this is a duplicate shot/same day, mark the dose number of the shot being evaluated as equal to prior shots administered on the same date; Invoke custom evaluation rules" 
	extends "Duplicate Shot/Same Day (Abstract): 2 shots administered on the same day"
	ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	agenda-group "makeNoteOfDuplicateShotSameDayIfAny"
	no-loop true
	when
		eval($tdprev.isShotIgnoredForCompletionOfSeries() == false || 
			($doseNumber > $targetSeries.getSeriesRules().getNumberOfDosesInSeries() && $targetSeries.getSeriesRules().recurringDosesOccurAfterSeriesComplete() == false) || 
			($tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber) != null && 
			$tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval() != null &&
			! $tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval().isEqualTo(new TimePeriod(0, DurationType.DAYS))))
	then
		String _RULENAME = kcontext.rule.name;
		modify ($td) {
			setDoseNumberInSeries($tdprevDoseNumber), 
			setPreEvaluationCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $targetSeries);
		setFocus("customEvaluationRule");
end


///////// ***
// General Design rule... Do not Edit
// If this shot is a duplicate shot/same day shot as another shot in the series, but interval is 0 days between them so latter shots' dose number is not set to same as previous shot
///////// ***
rule "Duplicate Shot/Same Day: duplicate shots on same day where interval is 0 days are not marked with the same dose number; Invoke custom evaluation rules" 
	extends "Duplicate Shot/Same Day (Abstract): 2 shots administered on the same day"
	ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	agenda-group "makeNoteOfDuplicateShotSameDayIfAny"
	no-loop true
	when
		eval($tdprev.isShotIgnoredForCompletionOfSeries() == true || 
			(($doseNumber <= $targetSeries.getSeriesRules().getNumberOfDosesInSeries() || $targetSeries.getSeriesRules().recurringDosesOccurAfterSeriesComplete() == true) &&
			($tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber) == null || 
			$tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval() == null ||
			$tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval().isEqualTo(new TimePeriod(0, DurationType.DAYS)))))
	then
		String _RULENAME = kcontext.rule.name;
		modify ($td) {
			setPreEvaluationCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $targetSeries);
		setFocus("customEvaluationRule");
end


///////// ***
// General Design rule... Do not Edit
// If this shot is not a duplicate shot/same day shot as another shot in the series, just move on to the custom rules
///////// ***
rule "Not Duplicate Shot/Same Day: No duplicate shots to shot being evaluated; Invoke custom evaluation rules" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	agenda-group "makeNoteOfDuplicateShotSameDayIfAny"
	when
		$td: TargetDose(isPreEvaluationCheckCompleted() == false, status == DoseStatus.EVALUATION_IN_PROCESS, $administrationDate : administrationDate, $tdAdministeredShotNumber : administeredShotNumberInSeries, 
			$tdAssociatedTargetSeries : associatedTargetSeries)
		not TargetDose(this != $td, administrationDate == $administrationDate, administeredShotNumberInSeries < $tdAdministeredShotNumber, associatedTargetSeries == $tdAssociatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($td) {
			setPreEvaluationCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $tdAssociatedTargetSeries);
		setFocus("customEvaluationRule");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusInvalid" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty == false) 
		$ts : TargetSeries(containsTargetDose($td))
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			setStatus(DoseStatus.INVALID),					// Also sets hasBeenEvaluated flag to true
			addDoseRuleProcessed(_RULENAME);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusNotEvaluated" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty, notEvaluatedReasons.empty == false) 
		$ts : TargetSeries(containsTargetDose($td))
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			setStatus(DoseStatus.NOT_EVALUATED),					// Also sets hasBeenEvaluated flag to true
			addDoseRuleProcessed(_RULENAME);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusAccepted" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty, notEvaluatedReasons.empty, acceptedReasons.empty == false)
		$ts : TargetSeries(containsTargetDose($td))
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			setStatus(DoseStatus.ACCEPTED),					// Also sets hasBeenEvaluated flag to true
			addDoseRuleProcessed(_RULENAME);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		setFocus("postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusValid" ruleflow-group "HistoryEvaluation"
	dialect "java"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty, acceptedReasons.empty, notEvaluatedReasons.empty)
		$ts : TargetSeries(containsTargetDose($td))
	then
		String _RULENAME = drools.getRule().getName();
		modify($td) {
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			addDoseRuleProcessed(_RULENAME),
			setStatus(DoseStatus.VALID);					// Also sets hasBeenEvaluated flag to true
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		drools.setFocus("postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.denoteDoseReadyForFinalEvaluationStatus" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 60
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS)
		$ts : TargetSeries(containsTargetDose($td))
	then
		String _RULENAME = kcontext.rule.name;
		$td.setStatus(DoseStatus.EVALUATION_COMPLETE);
		update($td);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
end


///////// ***
// Supplemental Series Table rule... modifying this rule not suggested
///////// ***
rule "HistoryEvaluation.markExtraneousDosesAcceptedIfCompleteForAllDiseaseTargetedByThisDose" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "extraDoseCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $doseNumber : doseNumberInSeries) 
		$ts : TargetSeries(containsTargetDose($td), isSeriesComplete() == true || seriesRules.numberOfDosesInSeries < determineDoseNumberInSeriesForDiseasesTargetedByThisDose($td)) 
	then
		String _RULENAME = kcontext.rule.name;
		$td.addAcceptedReason(BaseDataEvaluationReason._EXTRA_DOSE_EVALUATION_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkIsAllowableVaccine" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "allowableVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $vaccine : administeredVaccine, $doseNumber : doseNumberInSeries)
		$ts : TargetSeries(containsTargetDose($td), $doseNumber <= seriesRules.numberOfDosesInSeries, seriesRules.isAllowableVaccineForDoseRule($vaccine, $doseNumber) == false) 
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef);
		$td.addInvalidReason(BaseDataEvaluationReason._VACCINE_NOT_ALLOWED_FOR_THIS_DOSE.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);	
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkMinimumAgeVaccinePermitted" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "minimumAgeVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $adminage : vaccineComponent.validMinimumAgeForUse != null, $doseNumber : doseNumberInSeries)
		$ts : TargetSeries(containsTargetDose($td), $doseNumber <= seriesRules.numberOfDosesInSeries) // , seriesRules.isAllowableVaccineForDoseRule($vaccine, $doseNumber) == true)
		$person : EvaluatedPerson()
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($person.getDemographics().getBirthTime(), $td.getAdministrationDate(), $adminage) < 0)
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef);
		$td.addInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_AGE_VACCINE_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);	
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkMaximumAgeVaccinePermitted" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "maximumAgeVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $adminage : vaccineComponent.validMaximumAgeForUse != null, $doseNumber : doseNumberInSeries)
		$ts : TargetSeries(containsTargetDose($td), $doseNumber <= seriesRules.numberOfDosesInSeries)
		$person : EvaluatedPerson()
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($person.getDemographics().getBirthTime(), $td.getAdministrationDate(), $adminage) > 0)
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef)		
		$td.addInvalidReason(BaseDataEvaluationReason._ABOVE_MAX_AGE_VACCINE.getCdsListItemName());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateVaccineGroupMinimumAge" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseAgeCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $doseNumber : doseNumberInSeries) 
		$ts : TargetSeries(containsTargetDose($td), seriesRules.numberOfDosesInSeries >= $doseNumber)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMinimumAgeandRecordReason($person.demographics.birthTime, $td);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_AGE_EVALUATION_REASON.getCdsListItemName()) || 
			$td.containsInvalidReason(BaseDataEvaluationReason._INVALID_AGE_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._BELOW_MINIMUM_AGE.getConceptCodeValue(), $td);
			insert(hef)				
		}
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateVaccineGroupMinimumInterval" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseIntervalCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $admindose: administeredShotNumberInSeries >= 2, $doseNumber : doseNumberInSeries, $tddate : administrationDate, 
			$tdAssociatedTargetSeries : associatedTargetSeries)
		$tdprev : TargetDose(associatedTargetSeries == $tdAssociatedTargetSeries, administeredShotNumberInSeries < $admindose, administrationDate < $tddate, 
			isShotIgnoredForCompletionOfSeries() == false, $tdprevdate : administrationDate)
		not TargetDose(associatedTargetSeries == $tdAssociatedTargetSeries, administrationDate > $tdprevdate, administrationDate < $tddate, isShotIgnoredForCompletionOfSeries() == false)
		$ts : TargetSeries(containsTargetDose($td) && containsTargetDose($tdprev), seriesRules.numberOfDosesInSeries >= $doseNumber)
		not (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._BELOW_MINIMUM_AGE.conceptCodeValue, associatedTargetDose == $tdprev, associatedTargetDose.doseNumberInSeries == 1, 
			associatedTargetDose.administeredShotNumberInSeries == $admindose-1))
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMinimumIntervalAndRecordReason($td, $tdprev);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_INTERVAL_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._BELOW_MINIMUM_INTERVAL.getConceptCodeValue(), $td);
			insert(hef)				
		}
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series table rule... Do not Edit
///////// ***
rule "HistoryEvaluation: Evaluate minimum interval between first shot in seasonal series and most recent shot from a prior season" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseIntervalCheckFromPreviousSeason"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, administeredShotNumberInSeries == 1, $doseNumber : doseNumberInSeries)
		$ts : TargetSeries(containsTargetDose($td), seriesRules.numberOfDosesInSeries >= $doseNumber, targetSeason != null, $tseason : targetSeason, 
			$vaccineGroup : vaccineGroup, $tsid : targetSeriesIdentifier)
		$tsprev : TargetSeries(vaccineGroup == $vaccineGroup, targetDoses.size() > 0, targetSeriesIdentifier != $tsid, targetSeason != null, 
			$tseasonPrev : targetSeason, targetSeason.getFullySpecifiedSeasonStartDate().isBefore($tseason.getFullySpecifiedSeasonStartDate()))
		not TargetSeries(targetSeriesIdentifier != $tsprev.targetSeriesIdentifier, targetSeason != null, vaccineGroup == $vaccineGroup,
			targetDoses.size() > 0, targetSeason.fullySpecifiedSeasonStartDate.isAfter($tseasonPrev.getFullySpecifiedSeasonStartDate()) && 
			targetSeason.fullySpecifiedSeasonStartDate.isBefore($tseason.getFullySpecifiedSeasonStartDate()))
		$lastFromPrev: TargetDose(associatedTargetSeries == $tsprev, isShotIgnoredForCompletionOfSeries() == false, $shotNumber: administeredShotNumberInSeries)
		not TargetDose(associatedTargetSeries == $tsprev, isShotIgnoredForCompletionOfSeries() == false, administeredShotNumberInSeries > $shotNumber)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMinimumIntervalAndRecordReason($td, $lastFromPrev);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_INTERVAL_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._BELOW_MINIMUM_INTERVAL.getConceptCodeValue(), $td);
			insert(hef)				
		}
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in " + $ts + "; Prior Dose " + $lastFromPrev + " in " + $tsprev);
end


///////// ***
// Series table rule... Do not Edit
///////// ***
rule "HistoryEvaluation: Evaluate Shot as Invalid if it is not between the Season Start and End Dates" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseInSeasonCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $administrationDate : administrationDate)
		$ts : TargetSeries(containsTargetDose($td), targetSeason != null, targetSeason.dateIsApplicableToSeason($administrationDate, false) == false)
	then
		String _RULENAME = kcontext.rule.name;
		$td.addInvalidReason(BaseDataEvaluationReason._OUTSIDE_SEASON_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);				
end


///////// ***
// Supplemental Series Table rule... modifying this rule not suggested
// If all shots in the TargetSeries have been evaluated and the patient has reached immunity for every disease handled by this Series, mark in the TargetSeries that
// the patient is immune to all diseases.
///////// ***
rule "HistoryEvaluation: Set Immunity Flag in Series to True if Immune to All Diseases Tracked by this Series as of the Evaluation Time" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$ts : TargetSeries($diseasesSupportedByThisSeries : diseasesSupportedByThisSeries, isImmunityToAllDiseasesRecorded() == false)
		not TargetDose(hasBeenEvaluated == false) from $ts.targetDoses
		$diseaseImmunityList : List(size == $diseasesSupportedByThisSeries.size()) from 
			accumulate($di : DiseaseImmunity($d : disease, dateOfImmunity <= evalTime, disease memberOf $diseasesSupportedByThisSeries), collectList($di))
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setImmunityToAllDiseasesRecorded(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries immunityToAllDiseasesRecorded set to true for " + $ts); 
end


/*****************************************************************************************************************************************************************************/
// 																Series Selection 
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Insert TargetSeriesSelection (Tracker) on to the Fact List for each Vaccine Group/Season" ruleflow-group "SeriesSelection"
	dialect "java"
	salience 10
	when
		$tseries : TargetSeries($vg : getVaccineGroup(), $tseason : getTargetSeason())
		not (TargetSeriesSelection(getSeriesSelectionVaccineGroup() == $vg, getSeriesSelectionSeason() == $tseason))
	then
		String _RULENAME = drools.getRule().getName();
		TargetSeriesSelection tss = new TargetSeriesSelection($vg, $tseason, schedule);
		insert(tss);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection added to fact list: " + tss.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Initialize Next Non-Seasonal TargetSeriesSelection" ruleflow-group "SeriesSelection"
	dialect "mvel"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, $priority : seriesSelectionPriority, 
			$vg : seriesSelectionVaccineGroup, seriesSelectionSeason == null)
		// Perform selection on series; higher priority vaccine groups first and those with seasons in start date ascending order
		not TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionVaccineGroup != $vg, seriesSelectionPriority > $priority)
	then
		modify ($tss) {
			setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS);
		}
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection Initialized " + $tss.toString() + ", Vaccine Group Priority " + $tss.seriesSelectionPriority);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Initialize Next Seasonal TargetSeriesSelection" ruleflow-group "SeriesSelection"
	dialect "mvel"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, $priority : seriesSelectionPriority, 
			$vg : seriesSelectionVaccineGroup, seriesSelectionSeason != null, $season : seriesSelectionSeason)
		// Perform selection on series; higher priority vaccine groups first and those with seasons in start date ascending order
		not TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionVaccineGroup != $vg, seriesSelectionPriority > $priority) 		
		not TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionVaccineGroup == $vg, 
			seriesSelectionSeason != null && seriesSelectionSeason.fullySpecifiedSeasonStartDate.isBefore($season.fullySpecifiedSeasonStartDate))
	then
		modify ($tss) { 
			setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS);
		}
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection Initialized " + $tss.toString() + ", Vaccine Group Priority " + $tss.seriesSelectionPriority);
end


///////// ***
// General Design rule... Do not Edit 
// Updates series selection status for vaccine group to complete once series has been selected. 
///////// ***
rule "SeriesSelection: Change Series Selection Status To Complete" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 40
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS,
			$sss : seriesSelectionSeason)
		TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == true, targetSeason == $sss)
		not (TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == false, targetSeason == $sss))
	then
		String _RULENAME = kcontext.rule.name;
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_COMPLETE);
		update($tss);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection: " + $tss.toString() + "; *Series* *Selected* " + $tss.getSelectedSeriesName());
end


///////// ***
// General Design rule... Do not Edit 
// Retracts all TargetSeries and corresponding TargetDoses in a vaccine group that remain (i.e. - were not chosen). 
// For Seasonal Series, since recommendations are only made on the current season
///////// ***
rule "SeriesSelection: Retract All Series Not Selected in Vaccine Group" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 50
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, $sss : seriesSelectionSeason, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS || 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_COMPLETE)
		$selected : TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == true, targetSeason == $sss)
		$ts : TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == false, targetSeason == $sss)
	then
		String _RULENAME = kcontext.rule.name;
		for (TargetDose d : $ts.targetDoses) {
			ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose Retracted: " + d);
			retract(d);
		}
		retract($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries Retracted: " + $ts);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Default Series Selection Preprocess rule: invoke custom rules" ruleflow-group "SeriesSelection"
	dialect "mvel"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS) 
	then
		String _RULENAME = kcontext.rule.name;
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoking Series Selection rules for vaccine group: " + $tss.seriesSelectionVaccineGroup);
		update($tss);
		setFocus("customSeriesSelectionRules");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: For the Seasonal Series being evaluated for SeriesSelection that is not in the current season, set patient age time of interest to last date of season if no shots administered" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 2000
	activation-group "patientAgeTimeOfInterestForSeasonSeriesSelection"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS, seriesSelectionSeason != null, $sss : seriesSelectionSeason, 
			$tssvg : seriesSelectionVaccineGroup)
		not TargetSeries(seriesRules.vaccineGroup == $tssvg, selectedSeries == true, targetSeason == $sss)
		$ts : TargetSeries(vaccineGroup == $tssvg, selectedSeries == false,	targetSeason == $sss, numberOfShotsAdministeredInSeries == 0)
		exists TargetSeries(vaccineGroup == $tssvg, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", $ts.targetSeason.fullySpecifiedSeasonEndDate.toDate());
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: patientAgeTimeOfInterest set to season end date: " + $ts.targetSeason.fullySpecifiedSeasonEndDate.toDate());
		update($tss);
		setFocus("customSeriesSelectionRules");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: For the Seasonal Series being evaluated for SeriesSelection that is not in the current season, set patient age time of interest to last shot of the series" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 2000
	activation-group "patientAgeTimeOfInterestForSeasonSeriesSelection"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS, seriesSelectionSeason != null, $sss : seriesSelectionSeason, 
			$tssvg : seriesSelectionVaccineGroup)
		not TargetSeries(seriesRules.vaccineGroup == $tssvg, selectedSeries == true, targetSeason == $sss)
		$ts : TargetSeries(vaccineGroup == $tssvg, selectedSeries == false,	targetSeason == $sss, numberOfShotsAdministeredInSeries > 0)
		exists TargetSeries(vaccineGroup == $tssvg, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;	
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", $ts.lastShotAdministeredInSeries.administrationDate);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: patientAgeTimeOfInterest set to last shot date in series: " + $ts.lastShotAdministeredInSeries.administrationDate);
		update($tss);
		setFocus("customSeriesSelectionRules");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: For the Seasonal Series being evaluated for SeriesSelection that is in the current season, set patient age time of interest to the execution time" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 2500
	activation-group "patientAgeTimeOfInterestForSeasonSeriesSelection"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS, seriesSelectionSeason != null, $sss : seriesSelectionSeason, 
			$tssvg : seriesSelectionVaccineGroup)
		not TargetSeries(seriesRules.vaccineGroup == $tssvg, selectedSeries == true, targetSeason == $sss)
		$ts : TargetSeries(vaccineGroup == $tssvg, selectedSeries == false, targetSeason == $sss)
		not TargetSeries(vaccineGroup == $tssvg, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", evalTime);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: patientAgeTimeOfInterest set to execution time: " + evalTime);
		update($tss);
		setFocus("customSeriesSelectionRules");
end


///////////////////////////////////////////////////////////// Series Selection Catch-All Rules Start Here /////////////////////////////////////////////////////////////


///////// ***
// Supplemental Series Selection rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// For all vaccine groups, if a series has not been selected by one of the custom rules and there are one or more series that have been completed, 
// select the series with the fewest doses necessary required to complete the series. 
///////// ***
rule "SeriesSelection: Select already completed series that has the fewest doses defined if exists and no series was previously selected" ruleflow-group "SeriesSelection"
	dialect "mvel"
	activation-group "SeriesSelectionFewestDoses"
	salience 60
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS, $sss : seriesSelectionSeason)
		not (TargetSeries(selectedSeries == true, seriesRules.vaccineGroup == $ssvg, targetSeason == $sss))
		$ts1 : TargetSeries(seriesRules.vaccineGroup == $ssvg, isSeriesComplete() == true, $id1 : targetSeriesIdentifier, 
			$numberOfDosesInSeries1 : seriesRules.numberOfDosesInSeries, targetSeason == $sss)
		not (TargetSeries(seriesRules.vaccineGroup == $ssvg, isSeriesComplete() == true, $numberOfDosesInSeries1 > seriesRules.numberOfDosesInSeries, targetSeason == $sss))
	then
		String _RULENAME = kcontext.rule.name;
		$ts1.setSelectedSeries(true);
		$tss.setSelectedSeriesName($ts1.seriesName);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_COMPLETE);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: TargetSeries " + $ts1);
		update($ts1);
		update($tss);	
end


///////// ***
// Supplemental Series Selection rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If more than one series is complete but one of them has already been selected which completed after one of the other series, change the series
// selected to the one that was completed the soonest.
///////// ***
rule "SeriesSelection: Select already completed series with earliest completion date if exists and different completed series was previously selected" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 60
	activation-group "SeriesSelectionFewestDoses"
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS, $sss : seriesSelectionSeason)
		$ts1 : TargetSeries(seriesRules.vaccineGroup == $ssvg, $id1 : targetSeriesIdentifier, selectedSeries == true, targetSeason == $sss, $seriesComplete1 : isSeriesComplete(), 
			$lastNecessaryShotAdministered1 : getValidShotByDoseNumber(seriesRules.numberOfDosesInSeries))
		$ts2 : TargetSeries(seriesRules.vaccineGroup == $ssvg, $id2 : targetSeriesIdentifier, $id2 != $id1, selectedSeries == false, targetSeason == $sss, $seriesComplete2 : isSeriesComplete(), 
			$lastAdministeredShot2InSeries: lastShotAdministeredInSeries, $lastNecessaryShotAdministered2 : getValidShotByDoseNumber(seriesRules.numberOfDosesInSeries))
		eval($seriesComplete1 == true && $seriesComplete2 == true && ($lastAdministeredShot2InSeries == null || 
			($lastNecessaryShotAdministered1 != null && $lastNecessaryShotAdministered2 != null && $lastNecessaryShotAdministered2.getAdministrationDate() != null && 
				$lastNecessaryShotAdministered2.getAdministrationDate().before($lastNecessaryShotAdministered1.getAdministrationDate()))))
	then
		String _RULENAME = kcontext.rule.name;
		$ts1.setSelectedSeries(false);
		$ts2.setSelectedSeries(true);
		$tss.setSelectedSeriesName($ts2.seriesName);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_COMPLETE);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Previously Selected TargetSeries Retracted for Already Complete Series: " + $ts2);
		update($ts1);
		update($ts2);
end


// Select only available series if there is only one in the vaccine group
rule "SeriesSelection.SelectOnlySeriesRemainingInVaccineGroup" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 100
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS)
		not TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == true)
		$ts : TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == false)
		accumulate($tsthis : TargetSeries(vaccineGroup == $ssvg); $countInVG : count($tsthis); $countInVG == 1)		
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: TargetSeries " + $ts);
		$ts.setSelectedSeries(true);
		$tss.setSelectedSeriesName($ts.seriesName);
		update($ts);	
end


/*****************************************************************************************************************************************************************************/
// 											Ruleflow group for forecasting "RecommendationForecast"
/*****************************************************************************************************************************************************************************/


///////// ***	
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.findMostRecentAdministeredLiveVirusVaccineDate" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 10
	when
		$lvd : LiveVirusFact(LiveVirusDateSet == false)
		exists (TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED))
		exists (TargetDose(vaccineComponent.isLiveVirusVaccine == true))
		$maxdate : Date() from accumulate(TargetDose(vaccineComponent.isLiveVirusVaccine == true, $date : administrationDate), maxDate($date))
	then
		String _RULENAME = kcontext.rule.name;
		$lvd.setLiveVirusDate($maxdate);		
		$lvd.setLiveVirusDateSet(true);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Found most recent live virus vaccine administered on " + $lvd.getLiveVirusDate());
		update($lvd);
end


///////// ***	
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.findMostRecentAdministeredSelectAdjuvantProductVaccineDate" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 10
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDateSet == false)
		exists (TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED))
		exists (TargetDose(vaccineComponent.isSelectAdjuvantProduct == true))
		$maxdate : Date() from accumulate(TargetDose(vaccineComponent.isSelectAdjuvantProduct == true, $date : administrationDate), maxDate($date))
	then
		String _RULENAME = kcontext.rule.name;
		$dft.setFactDate($maxdate);		
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Found most recent adjuvant product vaccine administered on " + $dft.getFactDate());
		update($dft);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.setNextSeasonalTargetSeriesForRecommendation" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		$ts: TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED, $vg : vaccineGroup, isSelectedSeries() == true, targetSeason != null, 
			$tseasonStartDate : targetSeason.fullySpecifiedSeasonStartDate)
		not TargetSeries(vaccineGroup == $vg, targetSeason != null,	targetSeason.fullySpecifiedSeasonStartDate.isAfter($tseasonStartDate)) 
	then
		String _RULENAME = kcontext.rule.name;		
		RecommendationStatus newRecommendationStatus = RecommendationStatus.FORECASTING_IN_PROGRESS;
		$ts.setRecommendationStatus(newRecommendationStatus);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Forecasting TargetSeries " + $ts);
		setFocus("preRecommendationValidation");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.setNextNonSeasonalTargetSeriesForRecommendation" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		$ts: TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED, isSelectedSeries() == true, targetSeason == null)
	then
		String _RULENAME = kcontext.rule.name;		
		RecommendationStatus newRecommendationStatus = RecommendationStatus.FORECASTING_IN_PROGRESS;
		$ts.setRecommendationStatus(newRecommendationStatus);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Forecasting TargetSeries " + $ts);
		setFocus("preRecommendationValidation");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.applyPostRecommendationCheck" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 20
	no-loop true
	when
		$targetSeries : TargetSeries(isPostForecastCheckCompleted() == false && 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE ||
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED || recommendationStatus == RecommendationStatus.NOT_RECOMMENDED))
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Post recommendation check for TargetSeries " + $targetSeries.getSeriesName());
		update($targetSeries);
		setFocus("postRecommendationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.noteCompletionOfPostRecommendationCheck - Do _not_ reprocess recommendation rules" ruleflow-group "RecommendationForecast"
dialect "mvel"
	salience 10
	when
		$targetSeries : TargetSeries(isPostForecastCheckCompleted() == false, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE ||
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED || recommendationStatus == RecommendationStatus.NOT_RECOMMENDED))
then
	String _RULENAME = kcontext.rule.name;
	$targetSeries.setRecommendationStatus(RecommendationStatus.FORECASTING_COMPLETE);
	$targetSeries.setPostForecastCheckCompleted(true);
	update($targetSeries);
	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Note Completion of Post recommendation check for TargetSeries " + $targetSeries.getSeriesName());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.noteCompletionOfPostRecommendationCheck - _Do_ reprocess recommendation rules" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "postRecommendationCheck"
	when
		$targetSeries : TargetSeries(isPostForecastCheckCompleted() == false, recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		$targetSeries.clearRecommendations();
		$targetSeries.setPostForecastCheckCompleted(true);
		update($targetSeries);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Note Completion of Post recommendation check for TargetSeries " + $targetSeries.getSeriesName());
		setFocus("preRecommendationValidation");
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a live virus vaccine and other live virus shots have been administered less than 28 days from 
// the recommendation date, then adjust the earliest recommendation date to be 28 days later than the most recent live virus shot
///////// ***
rule "RecommendationForecast.adjustEarliestRecommendedDateDueToLiveVirus" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$lvd : LiveVirusFact(liveVirusDate != null, liveVirusDateSet == true)				  
		$targetSeries : TargetSeries($earliestDate : getFinalEarliestDate() != null, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedLiveVirusVaccine() == true,
				liveVirusDatesAccountedForInRecommendedFinalEarliestDate not contains $lvd.liveVirusDate)
		eval((TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, true).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS))) || 
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS))))
	then
		String _RULENAME = kcontext.rule.name;
		Date $newRecommendationDate = TimePeriod.addTimePeriod($lvd.liveVirusDate, new TimePeriod(28, DurationType.DAYS));
		$targetSeries.setFinalEarliestDate($newRecommendationDate);
		$targetSeries.addLiveVirusDateAccountedForInRecommendedFinalEarliestDate($lvd.liveVirusDate);
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Earliest date adjustment from " + $earliestDate + " to " + $newRecommendationDate + " due to live virus vaccine administered on : " + $lvd.liveVirusDate + " in TargetSeries " + $targetSeries.getSeriesName());
		update($targetSeries);
		update($lvd);
end 


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a live virus vaccine and other live virus shots have been administered less than 28 days from 
// the recommendation date, then adjust the recommendation date to be 28 days later than the most recent live virus shot
///////// ***
rule "RecommendationForecast.adjustRecommendedDateDueToLiveVirus" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$lvd : LiveVirusFact(liveVirusDate != null, liveVirusDateSet == true)
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedLiveVirusVaccine() == true,
				liveVirusDatesAccountedForInRecommendedFinalDate not contains $lvd.liveVirusDate)
		eval((TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, true).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS))) || 
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS))))
	then
		String _RULENAME = drools.getRule().getName();
		Date newRecommendationDate = TimePeriod.addTimePeriod($lvd.liveVirusDate, new TimePeriod(28, DurationType.DAYS));
		$targetSeries.setFinalRecommendationDate(newRecommendationDate);
		$targetSeries.addLiveVirusDateAccountedForInRecommendedFinalDate($lvd.liveVirusDate);
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "evalTime " + evalTime + "; Recommendation date adjustment from " + $recommendationDueDate + " to " + newRecommendationDate + " due to live virus vaccine administered on : " + $lvd.liveVirusDate + " in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);
		update($lvd);		
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a select adjuvant product and other select adjuvant product shots been administered less than 28 days
// from the recommendation date, then adjust the earliest recommendation date to be 28 days later than the most recent select adjuvant product
///////// ***
rule "RecommendationForecast.adjustEarliestRecommendedDateDueToSelectAdjuvantProduct" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDate != null, factDateSet == true, $dftDate : factDate)
		$targetSeries : TargetSeries($earliestDate : getFinalEarliestDate() != null, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedSelectAdjuvantProduct() == true)  
		eval((TimePeriod.differenceInDays($dftDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, true).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($dftDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS))) || 
			TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS))))
	then
		String _RULENAME = kcontext.rule.name;
		Date $newRecommendationDate = TimePeriod.addTimePeriod($dftDate, new TimePeriod(28, DurationType.DAYS));
		$targetSeries.setFinalEarliestDate($newRecommendationDate);
		$targetSeries.addAdjuvantDateAccountedForInRecommendedFinalDate($dftDate);
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Earliest date adjustment from " + $earliestDate + " to " + $newRecommendationDate + " due to select adjuvant product administered on : " + $dftDate + " in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a select adjuvant product and other select adjuvant product shots have been administered less than 28 days
// from the recommendation date, then adjust the recommendation date to be 28 days later than the most recent select adjuvant product
///////// ***
rule "RecommendationForecast.adjustRecommendedDateDueToSelectAdjuvantProduct" ruleflow-group "RecommendationForecast"
	dialect "java"
	agenda-group "supplementalSeriesRule"
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDate != null, factDateSet == true, $dftDate : factDate)
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedSelectAdjuvantProduct() == true)  
		eval((TimePeriod.differenceInDays($dftDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, true).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($dftDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS))) || 
			TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS))))
	then
		String _RULENAME = drools.getRule().getName();
		Date $newRecommendationDate = TimePeriod.addTimePeriod($dftDate, new TimePeriod(28, DurationType.DAYS));
		$targetSeries.setFinalRecommendationDate($newRecommendationDate);
		$targetSeries.addAdjuvantDateAccountedForInRecommendedFinalDate($dftDate);
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Recommendation date adjustment from " + $recommendationDueDate + " to " + $newRecommendationDate + " due to select adjuvant product administered on : " + $dftDate + " in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);	
end 


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.adjustTargetSeriesEnclosedRecommendationWithRespectToEvalTime" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	no-loop true
	when
		$targetSeries : TargetSeries($recommendationDueDate : finalRecommendationDate)
		List(size > 0) from	accumulate($recs : Recommendation((recommendationStatus == RecommendationStatus.NOT_FORECASTED && recommendationReason != null) || 
				(recommendationStatus == RecommendationStatus.RECOMMENDED && $recommendationDueDate > evalTime) || 
				(recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE && $recommendationDueDate <= evalTime)) from $targetSeries.finalRecommendations, collectList($recs))
	then
		String _RULENAME = kcontext.rule.name;
		// Update the recommendation status and reason; if they are not updated, then just update the recommendation status only of NOT_FORECASTED recommendation objects to target series' status
		if ($targetSeries.adjustRecommendationStatusAndReasonByEvalTime(evalTime) == false) {
			for (Recommendation r : $targetSeries.getFinalRecommendations()) {
				if (r.getRecommendationStatus() == RecommendationStatus.NOT_FORECASTED) {
					r.setRecommendationStatus($targetSeries.getRecommendationStatus);
				}
			}
		}
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Enclosed Recommendation statuses adjusted in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.adjustRecommendedStatusAndEnclosedRecommendationsWithRespectToEvalTime" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED),
			$recommendationDueDate > evalTime && recommendationStatus == RecommendationStatus.RECOMMENDED || $recommendationDueDate <= evalTime && recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE)
	then
		String _RULENAME = kcontext.rule.name;
		$targetSeries.adjustRecommendationStatusAndReasonByEvalTime(evalTime);
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Recommendation status and enclosed Recommendations adjusted for " + $recommendationDueDate + " in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);	
end


///////// ***
// General Design rule... Do not Edit
// Per ICE SME group, if recommendation is conditional, do not display a recommendation date. This can be overrided via TargetSeries.setDisplayForecastDateForConditionalRecommendations()
///////// ***
rule "RecommendationForecast.doNotReturnForecastDateForConditionalRecommendations" ruleflow-group "RecommendationForecast"
	dialect "java"
	agenda-group "supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, isForecastDateDisplayedForConditionalRecommendations() == false, 
			finalRecommendationDate != null || finalEarliestDate != null || finalOverdueDate != null)
	then
		String _RULENAME = drools.getRule().getName();
		$ts.setFinalRecommendationDate(null);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.getSeriesName());
end


///////// ***
// General Design rule... Do not Edit
// If the list of recommended vaccines are inconsistent (i.e. - different interim recommendation forecasts with different vaccines), and the patient is recommended 
// for a forecast, then log the inconsistency and recommend at the vaccine group level
///////// ***
rule "RecommendationForecast.recommendedAtVaccineGroupLevelIfRecommendedVaccinesNotConsistentWithRecommendationObjects" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE ||
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations)
		HashSet(size > 1) from accumulate(Recommendation(recommendedVaccine != null, $accRecommendedVaccine : recommendedVaccine) from $tsFinalRecommendations, collectSet($accRecommendedVaccine))
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationVaccine(null);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General Design rule... Do not Edit
// If the list of recommended vaccines are inconsistent (i.e. - different interim recommendation forecasts with different vaccines), and the patient is recommended 
// for a forecast, then log the inconsistency and recommend at the vaccine group level
///////// ***
rule "RecommendationForecast.recommendedAtVaccineGroupLevelIfRecommendedVaccinesNotConsistentWithTargetSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations, recommendationVaccine != null, 
			$tsRecommendedVaccine: recommendationVaccine)
		HashSet(size > 0) from accumulate(Recommendation(recommendedVaccine != null, recommendedVaccine != $tsRecommendedVaccine, $accRecommendedVaccine : recommendedVaccine) 
			from $tsFinalRecommendations, collectSet($accRecommendedVaccine))
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationVaccine(null);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end

	
///////// ***
// General Design rule... Do not Edit
// If the list of recommended vaccines are consistent and not all empty, and the patient is recommended for a forecast, then recommend at the vaccine level of the only specified vaccine.
// Set each Recommendation Object's recommendedVaccine to null and set the TargetSeries recommendationVaccine to the 1 and only 1 vaccine
///////// ***
rule "RecommendationForecast.recommendedAtVaccineLevelIfRecommendedVaccinesConsistentWithRecommendationObjects" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations)
		$recommendationVaccineSet : Set(size == 1) from accumulate(Recommendation(recommendedVaccine != null, $accRecommendedVaccine : recommendedVaccine) from $tsFinalRecommendations, collectSet($accRecommendedVaccine))
		$tsSame : TargetSeries(targetSeriesIdentifier == $ts.targetSeriesIdentifier, recommendationVaccine == null || recommendationVaccine != null && recommendationVaccine memberOf $recommendationVaccineSet)
		$recommendationVaccineList : List() from accumulate($acc2Recommendation : Recommendation(recommendedVaccine != null) from $tsFinalRecommendations, collectList($acc2Recommendation))
	then
		String _RULENAME = kcontext.rule.name;
		Iterator iter = $recommendationVaccineSet.iterator();
		if (iter.hasNext()) {
			Vaccine v = (Vaccine) iter.next();
			$ts.setRecommendationVaccine(v);
		}
		Iterator iter2 = $recommendationVaccineList.iterator();
		while (iter2.hasNext()) {
			Recommendation r = (Recommendation) iter2.next();
			r.setRecommendedVaccine(null);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General Design rule... Do not Edit
// Recommend at vaccine group level if recommendation status (forecast) is NOT_RECOMMENDED
///////// ***
rule "RecommendationForecast.recommendedAtVaccineGroupLevelIfNotRecommendedForecast" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.NOT_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationVaccine(null);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.finalizeRecommendationsForSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)	
		not Recommendation(targetSeriesIdentifier == $ts.targetSeriesIdentifier)	
	then
		String _RULENAME = kcontext.rule.name;
		$ts.finalizeRecommendationsForForecasting();
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Finalized recommendations for TargetSeries " + $ts.getSeriesName());
		update($ts);
		setFocus("supplementalSeriesRule");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.addAnyRecommendationsOnFactListToSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)
		$recommendation : Recommendation(targetSeriesIdentifier == $ts.targetSeriesIdentifier)	
	then
		String _RULENAME = kcontext.rule.name;
		$ts.addInterimRecommendationForConsideration($recommendation, evalTime);
		retract($recommendation);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Finalized recommendations for TargetSeries " + $ts.getSeriesName());
		update($ts);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.allRecommendationRulesProcessedForSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 95
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationStatus(RecommendationStatus.FORECASTING_COMPLETE);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
// To follow CDC guidelines, could change this to only fire if a recommended age is available; then calculate earliest possible recommended date above
// using minimal age, minimum interval, etc. This separates the catch up schedule from the short recommendation intervals used by NYC
///////// ***
rule "RecommendationForecast.recommendBasedOnEarliestAgeRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "earliestAgeCheck"
	when
		// To follow CDC guidelines, could change this to check that a recommended age is provided
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestAgeRule($person.demographics.birthTime, $evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series Table rule... Do not edit
// To follow CDC guidelines, could change this to only fire if a recommended age is not available
///////// ***
rule "RecommendationForecast.recommendBasedOnEarliestIntervalRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "earliestIntervalCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		//
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestIntervalRule($evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
// To follow CDC guidelines, could change this to only fire if a recommended age is available; then calculate earliest possible recommended date above
// using minimal age, minimum interval, etc. This separates the catch up schedule from the short recommendation intervals used by NYC
///////// ***
rule "RecommendationForecast.recommendBasedOnLatestRecommendedAgeRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "latestRecommendedAgeCheck"
	when
		// To follow CDC guidelines, could change this to check that a recommended age is provided
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnLatestRecommendedAgeRule($person.demographics.birthTime, $evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series Table rule... Do not edit
// To follow CDC guidelines, could change this to only fire if a recommended age is not available
///////// ***
rule "RecommendationForecast.recommendBasedOnLatestRecommendedIntervalRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "latestRecommendedIntervalCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		//
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnLatestRecommendedIntervalRule($evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series table rule... Do not Edit
// To follow CDC guidelines, could change this to only fire if a recommended age is available; then calculate earliest possible recommended date above
// using minimal age, minimum interval, etc. This separates the catch up schedule from the short recommendation intervals used by NYC
///////// ***
rule "RecommendationForecast.recommendBasedOnEarliestRecommendedAgeRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "recommendationAgeCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestRecommendedAgeRule($person.demographics.birthTime, $evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "RecommendationForecast.recommendBasedOnRecommendedIntervalRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "recommendationIntervalCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestRecommendedIntervalRule($evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


rule "RecommendationForecast.Do Not Apply Earliest Interval for Dose 1 if Prior Shot for Target Dose 1 was Invalid due to Below Minimum Age" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 101
	activation-group "earliestIntervalCheck"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS, isSeriesComplete() == false, determineDoseNumberInSeries() == 1,
			$lastShotAdministered : lastShotAdministeredInSeries, $lastShotAdministered != null, $lastShotAdministered.doseNumberInSeries == 1,	
			$lastShotAdministered.getAdministeredVaccine().isLiveVirusVaccine() == false, $lastShotAdministered.getAdministeredVaccine().isSelectAdjuvantProduct() == false) 
		exists ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._BELOW_MINIMUM_AGE.conceptCodeValue, associatedTargetDose == $lastShotAdministered)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


rule "RecommendationForecast.Do Not Apply Recommended Interval for Dose 1 if Prior Shot for Target Dose 1 was Invalid due to Below Minimum Age" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 101
	activation-group "recommendationIntervalCheck"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS, isSeriesComplete() == false, determineDoseNumberInSeries() == 1,
			$lastShotAdministered : lastShotAdministeredInSeries, $lastShotAdministered != null, $lastShotAdministered.doseNumberInSeries == 1,
			$lastShotAdministered.getAdministeredVaccine().isLiveVirusVaccine() == false, $lastShotAdministered.getAdministeredVaccine().isSelectAdjuvantProduct() == false) 
		exists ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._BELOW_MINIMUM_AGE.conceptCodeValue, associatedTargetDose == $lastShotAdministered)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// For seasonal series, recommend shot on the first date of the next season or at the time that the patient becomes of minimum age
// Overrides age check
///////// ***
rule "RecommendationForecast: Recommend Earliest Recommended Age Date in Next Series Season as Specified by Default Season Series Rule if no next Fully-Specified Season Defined and during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "recommendationAgeCheck"
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, $vg : vaccineGroup, targetSeason.dateIsApplicableToOffSeason(evalTime),
			$offSeasonEndDate : targetSeason.fullySpecifiedSeasonOffSeasonEndDate)
		not Season(isDefaultSeason() == false, vaccineGroup == $vg, fullySpecifiedSeasonStartDate.toDate() == $offSeasonEndDate.plusDays(1).toDate())
		$defaultSeason : Season(isDefaultSeason() == true, vaccineGroup == $vg)
		$s : SeriesRules(vaccineGroup == $vg, $defaultSeason memberOf seasons, getSeriesDoseRuleByDoseNumber(1) != null,
			$recommendedAge : getSeriesDoseRuleByDoseNumber(1).getEarliestRecommendedAge() != null)
		$person : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($birthDate, $offSeasonEndDate.plusDays(1).toDate(), $recommendedAge) > 0)		
	then
		String _RULENAME = kcontext.rule.name;
		Date calcRecDate = TimePeriod.addTimePeriod($birthDate, $recommendedAge);
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate(calcRecDate);
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);			
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// Recommend earliest recommended age date in the next series for each series rules that have a recommended age and for which there is an associated fully-specified season
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend at Earliest Recommended Age Date in Next Series Season as Specified by TargetSeries if Fully-Specified Season Defined and if during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "recommendationAgeCheck"
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, targetSeason.dateIsApplicableToOffSeason(evalTime), 
			$offSeasonEndDate : targetSeason.fullySpecifiedSeasonOffSeasonEndDate, $offSeasonEndDate != null)
		$fullySpecifiedNextseason : Season(isDefaultSeason() == false, vaccineGroup == $ts.vaccineGroup, fullySpecifiedSeasonStartDate.toDate() == $offSeasonEndDate.plusDays(1).toDate())
		$sr : SeriesRules(vaccineGroup == $ts.vaccineGroup, $fullySpecifiedNextseason memberOf seasons, getSeriesDoseRuleByDoseNumber(1) != null,
			$recommendedAge : getSeriesDoseRuleByDoseNumber(1).getEarliestRecommendedAge() != null)
		$person : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($birthDate, $offSeasonEndDate.plusDays(1).toDate(), $recommendedAge) > 0)		
	then
		String _RULENAME = kcontext.rule.name;
		Date calcRecDate = TimePeriod.addTimePeriod($birthDate, $recommendedAge);
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate(calcRecDate);
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);			
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// For seasonal series, patients should receive a shot on the first date of the next season if evaluation time is *after* the season ended in current series
// Overrides interval check.
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend Next Season Earliest Start Date if during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "earliestIntervalCheck"	
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, targetSeason.dateIsApplicableToOffSeason(evalTime))
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setEarliestDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);	
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// For seasonal series, patients should receive a shot on the first date of the next season if evaluation time is *after* the season ended in current series
// Overrides interval check.
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend Next Season Recommended Start Date if during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "recommendationIntervalCheck"	
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, targetSeason.dateIsApplicableToOffSeason(evalTime)) 
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);	
end


///////// ***
// Series Table rule... Do not Edit
// For seasonal series, if the series is complete, recommend that the patient receive a shot on the season start date of the next season
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend Next Season Start Date if Current Seasonal Series is Complete" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, isSeriesComplete() == true, targetSeason != null, 
			targetSeason.fullySpecifiedSeasonOffSeasonEndDate != null)
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
// For seasonal series, if the final recommendation date falls between the off-season start and end dates, modify the recommendation date to the
// beginning of the next season 
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast/Post Recommendation Check: Recommend Next Season Start Date if Final Recommendation Date during Off-Season" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "postRecommendationCheck"
	when
		$ts : TargetSeries(isPostForecastCheckCompleted() == false, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendationDate != null, $pcvRecommendationDate : finalRecommendationDate, 
			targetSeason != null, finalRecommendationDate != null, targetSeason.fullySpecifiedSeasonOffSeasonStartDate != null, targetSeason.fullySpecifiedSeasonOffSeasonEndDate != null) 
		eval($ts.getFinalRecommendationDate().compareTo($ts.getTargetSeason().getFullySpecifiedSeasonEndDate().toDate()) > 0 && 
			$ts.getFinalRecommendationDate().compareTo($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().toDate()) <= 0)
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);		
end


///////// ***
// Series Table rule... Do not Edit
// For seasonal series, if the final recommendation date falls after the season end-date and there is no off-season, mark the series NOT_RECOMMENDED and COMPLETE, as there will
// not be a next season (this is the one-and-only season as indicated by the fact that there is no off-season)
///////// ***
rule "RecommendationForecast/Post Recommendation Check: Recommend Not Recommended and Complete if Final Recommendation Date after End Date and there is no Off-Season" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	agenda-group "postRecommendationCheck"
	activation-group "postSeasonalSeriesNotRecommendedHandling"
	when
		$ts : TargetSeries(isPostForecastCheckCompleted() == false, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendationDate != null, $pcvRecommendationDate : finalRecommendationDate, 
			targetSeason != null, finalRecommendationDate != null, targetSeason.fullySpecifiedSeasonOffSeasonEndDate == null) 
		eval($ts.getFinalRecommendationDate().compareTo($ts.getTargetSeason().getFullySpecifiedSeasonEndDate().toDate()) > 0)
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation $recommendation = new Recommendation($ts); 
		$recommendation.setRecommendationStatus(RecommendationStatus.NOT_RECOMMENDED);
		$recommendation.setRecommendationReason(BaseDataRecommendationReason._NOT_RECOMMENDED_COMPLETE_REASON.getCdsListItemName());
		$ts.setSeriesComplete(true);
		$ts.addInterimRecommendationForConsideration($recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);		
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If the patient is immune (for any reason) to all of the diseases handled by the TargetSeries, mark the series and forecasting complete
///////// ***
rule "RecommendNotRecommendedIfImmuneToAllDiseasesInSeries" ruleflow-group "RecommendationForecast"
	dialect "java"
	agenda-group "preRecommendationValidation"
	when
		$targetSeries : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS, $diseasesSupportedByThisSeries : diseasesSupportedByThisSeries)
		do[invokeCustomRecommendationRules]
		$diseaseImmunityList : List(size == $diseasesSupportedByThisSeries.size()) from 
			accumulate($di : DiseaseImmunity($d : disease, dateOfImmunity <= evalTime, disease memberOf $diseasesSupportedByThisSeries), collectList($di))
	then
		String _RULENAME = drools.getRule().getName();
		Recommendation $recommendation = new Recommendation($targetSeries); 
		$recommendation.setRecommendationStatus(RecommendationStatus.NOT_RECOMMENDED);
		Iterator dilIter = $diseaseImmunityList.iterator();
		while (dilIter.hasNext()) {	// Just take the first available immunity reason
			DiseaseImmunity diConsequence = (DiseaseImmunity) dilIter.next();
			String src = diConsequence.getRecommendationReasonResult();
			if (src != null) {
				$recommendation.setRecommendationReason(src);
				break;				
			}
		}
		$targetSeries.addInterimRecommendationForConsideration($recommendation, evalTime);
		$targetSeries.setSeriesComplete(true);
		modify ($targetSeries) {setRecommendationStatus(RecommendationStatus.FORECASTING_COMPLETE); }
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
       	ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $targetSeries.getSeriesName());
	then[invokeCustomRecommendationRules]
       	ICELogicHelper.logDRLDebugMessage(drools.getRule().getName(), "Check complete.");
       	drools.setFocus("customRecommendationRule");
end


/*****************************************************************************************************************************************************************************/
// 													Ruleflow group for returning results
/*****************************************************************************************************************************************************************************/


///////// ***
// General Design rule... Do not Edit
///////// ***
function void setShotValidity(SubstanceAdministrationEvent sae, TargetDose td) {
	
	if (sae == null || td == null) {
		return;
	}
	
	BL currShotValidity = sae.getIsValid();
	if (currShotValidity == null || currShotValidity.isValue() == true) {
		BL shotValidity = new BL();
		shotValidity.setValue(td.getIsValid());
		sae.setIsValid(shotValidity);
	}

}


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Evaluations" ruleflow-group "ProcessResults"
	dialect "mvel"
	lock-on-active true
	salience 10
	when
		$sae : SubstanceAdministrationEvent()	
		$td : TargetDose(doseId == $sae.id)
		$ts : TargetSeries(containsTargetDose($td), $vaccineGroup : seriesRules.vaccineGroup, selectedSeries == true)
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputNestedImmEvaluationResult(drools, namedObjects, $evalTime, focalPersonId, $sae, $vaccineGroup, $td);
		$sae.setToBeReturned(true);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing: " + $td);	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Mark Unprocessed Shots as Vaccine Not Supported" ruleflow-group "ProcessResults"
	dialect "mvel"
	lock-on-active true
	salience 10
	when
		ImmunizationConcept($ctid : conceptTargetId)
		$sae : SubstanceAdministrationEvent(id == $ctid)
		not TargetDose(doseId == $sae.id)
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputNestedImmEvaluationNotSupported(drools, namedObjects, $evalTime, focalPersonId, $sae, "VACCINE_GROUP_CONCEPT.999");
		$sae.setToBeReturned(true);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing: " + $sae);	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Recommendations for Vaccines Not Supported" extends "ProcessResults: Mark Unprocessed Shots as Vaccine Not Supported" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 10
	when
		not ObservationResult(observationValue != null && observationValue.concept != null && 
			observationValue.concept == PayloadHelper.getLocalCodeForRecommendationStatus(RecommendationStatus.RECOMMENDATION_NOT_AVAILABLE, schedule))
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.outputOtherImmRecommendationSubstanceAdministrationProposal(drools, namedObjects, focalPersonId); 
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Check Non-Seasonal Series Selection Consistency" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 20
	when
		$s : SeriesRules($vg : vaccineGroup)
		exists TargetSeries(vaccineGroup == $vg, targetSeason == null)
		accumulate($tsthis : TargetSeries(vaccineGroup == $vg, isSelectedSeries() == true, targetSeason == null); $countInVG : count($tsthis); $countInVG != 1)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.throwRuntimeException(new InconsistentConfigurationException("No series properly selected for vaccine group " + $vg));
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "No series properly selected for vaccine group " + $vg);			
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Check Seasonal SeriesSelection Consistency" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 20
	when
		$season: Season(isDefaultSeason() == false, $vg : vaccineGroup)
		exists TargetSeries(vaccineGroup == $vg, targetSeason != null, targetSeason == $season)
		accumulate($tsthis : TargetSeries(vaccineGroup == $vg, isSelectedSeries() == true, targetSeason == $season); $countInVG : count($tsthis); $countInVG != 1)			
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.throwRuntimeException(new InconsistentConfigurationException("No series properly selected for vaccine group " + $vg));
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "No series properly selected for vaccine group " + $vg);			
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Recommendation for Non-Seasonal Series" ruleflow-group "ProcessResults"
	dialect "mvel"
	lock-on-active true
	salience 10
	when
		$ts : TargetSeries(targetSeason == null)
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		SubstanceAdministrationProposal sap = p.OutputRootImmRecommendationSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, $ts, outputEarliestOverdueDates);
		insert(sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end

	
///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Recommendations For Seasonal Series" ruleflow-group "ProcessResults"
	dialect "mvel"
	lock-on-active true
	salience 10
	when
		$ts : TargetSeries($vg : vaccineGroup, targetSeason != null, isSelectedSeries() == true, $tseasonStartDate : targetSeason.fullySpecifiedSeasonStartDate)
		not TargetSeries(vaccineGroup == $vg, targetSeason != null,	targetSeason.fullySpecifiedSeasonStartDate.isAfter($tseasonStartDate)) 
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputRootImmRecommendationSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, $ts, outputEarliestOverdueDates);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Output number of doses remaining START
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////// ***
// Supplemental Output rule... Output doses remaining to Recommendation for a Series that is Not Recurring and Not Complete
///////// ***
rule "ProcessResults: Append Number of Doses Remaining to Recommendation for a Series (not Influenza) that is Not Recurring and Not Complete" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$sap : SubstanceAdministrationProposal($sapid : id)
		$ts : TargetSeries(targetSeriesIdentifier == $sapid, vaccineGroup != "VACCINE_GROUP_CONCEPT.800", getSeriesRules().recurringDosesOccurAfterSeriesComplete() == false, 
			isSeriesComplete() == false, $numberOfDosesAdministered : determineEffectiveNumberOfDosesInSeries(), $numberOfDosesInSeries : seriesRules.numberOfDosesInSeries, 
			recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED)
	then
		String _RULENAME = kcontext.rule.name;
		int lNumberRemaining = $numberOfDosesInSeries-$numberOfDosesAdministered;
		String lStrNumberRemaining = String.valueOf(lNumberRemaining);
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputEmbeddedDosesRemainingInSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, lStrNumberRemaining, $sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ts.getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);	
end


///////// ***
// Supplemental Output rule... Output "Recurring" to Recommendation for Influenza; overrides appending of number of doses remaining
///////// ***
rule "ProcessResults: Append Recurring to Recommendation for Influenza" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$sap : SubstanceAdministrationProposal($sapid : id)
		$ts : TargetSeries(targetSeriesIdentifier == $sapid, vaccineGroup == "VACCINE_GROUP_CONCEPT.800", recommendationStatus == RecommendationStatus.RECOMMENDED || 
			recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "RECURRING";
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputEmbeddedDosesRemainingInSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, lStrNumberRemaining, $sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ts.getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);	
end


///////// ***
// Supplemental Output rule... Output Zero Doses Remaining to Recommendation for a Series that is Not Recurring and Complete
///////// ***
rule "ProcessResults: Append Zero Doses Remaining to Recommendation for a Series that is Not Recurring and Complete" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$sap : SubstanceAdministrationProposal($sapid : id)
		$ts : TargetSeries(targetSeriesIdentifier == $sapid, getSeriesRules().recurringDosesOccurAfterSeriesComplete() == false, isSeriesComplete() == true, 
			recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "0"
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputEmbeddedDosesRemainingInSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, lStrNumberRemaining, $sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ts.getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);	
end


///////// ***
// Supplemental Output rule... Output doses N/A for Doses Remaining to Recommendation for a Series that is Recurring
///////// ***
rule "ProcessResults: Append Recurring for Doses Remaining to Recommendation for a Series that is Recurring" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$sap : SubstanceAdministrationProposal($sapid : id)
		$ts : TargetSeries(targetSeriesIdentifier == $sapid, getSeriesRules().recurringDosesOccurAfterSeriesComplete() == true, 
			recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE, 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "RECURRING";
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputEmbeddedDosesRemainingInSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, lStrNumberRemaining, $sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ts.getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);
end


///////// ***
// Supplemental Output rule... Output doses N/A for Doses Remaining to Recommendation for a Series that is Not Recommended
///////// ***
rule "ProcessResults: Append N/A for Doses Remaining to Recommendation for a Series that is Not Recommended" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$sap : SubstanceAdministrationProposal($sapid : id)
		$ts : TargetSeries(targetSeriesIdentifier == $sapid, recommendationStatus == RecommendationStatus.NOT_RECOMMENDED)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "N/A";
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputEmbeddedDosesRemainingInSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, lStrNumberRemaining, $sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ts.getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Output number of doses remaining END
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set flag to be returned for all Entities and ClinicalStatements number of doses remaining START
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "BounceAllEntities" ruleflow-group "ProcessResults"
	dialect "mvel"
	when
		$entityBase : EntityBase( toBeReturned == false )
	then
		String _RULENAME = kcontext.rule.name;
		$entityBase.setToBeReturned( true );
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "BounceAllClinicalStatements" ruleflow-group "ProcessResults"
	dialect "mvel"
	when
		$cs : ClinicalStatement( toBeReturned == false )
	then
		String _RULENAME = kcontext.rule.name;
		$cs.setToBeReturned( true );
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set flag to be returned for all Entities and ClinicalStatements number of doses remaining END
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//NOTE:  all demographics about the Patient are always returned in the result 
//			when the result is an outputVMR.

//NOTE2:  all ClinicalStatements, except ObservationResults are always returned as root elements

//NOTE3:  all Entities that have a relationship to a ClinicalStatement or to another Entity 
//			are always returned nested within that ClinicalStatement or Entity ONLY if that
//			ClinicalStatement or Entity is flagged toBeReturned.  

//NOTE4:  all Entities that are related directly to the patient will be returned or not
//			depending on the setting of the toBeReturned flag.



