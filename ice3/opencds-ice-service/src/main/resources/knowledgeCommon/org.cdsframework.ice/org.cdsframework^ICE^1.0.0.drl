/**
 * Copyright (C) 2024 New York City Department of Health and Mental Hygiene, Bureau of Immunization
 * Contributions by HLN Consulting, LLC
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU
 * Lesser General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. You should have received a copy of the GNU Lesser
 * General Public License along with this program. If not, see <http://www.gnu.org/licenses/> for more
 * details.
 *
 * The above-named contributors (HLN Consulting, LLC) are also licensed by the New York City
 * Department of Health and Mental Hygiene, Bureau of Immunization to have (without restriction,
 * limitation, and warranty) complete irrevocable access and rights to this project.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; THE
 *
 * SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
 * BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, IF ANY, OR DEVELOPERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES, OR OTHER LIABILITY OF ANY KIND, ARISING FROM, OUT OF, OR IN CONNECTION WITH
 * THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information about this software, see http://www.hln.com/ice or send
 * correspondence to ice@hln.com.
 */ 
 
package knowledgeCommon.org.cdsframework.ice

import java.util.ArrayList
import java.util.Collection
import java.util.Date
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import java.util.HashSet
import java.util.HashMap
import org.drools.core.spi.KnowledgeHelper
import org.opencds.vmr.v1_0.internal.AdministrableSubstance
import org.opencds.vmr.v1_0.internal.ClinicalStatement
import org.opencds.vmr.v1_0.internal.ClinicalStatementRelationship
import org.opencds.vmr.v1_0.internal.EntityBase
import org.opencds.vmr.v1_0.internal.EvaluatedPerson
import org.opencds.vmr.v1_0.internal.EvalTime
import org.opencds.vmr.v1_0.internal.ObservationResult
import org.opencds.vmr.v1_0.internal.ObservationValue
import org.opencds.vmr.v1_0.internal.SubstanceAdministrationEvent
import org.opencds.vmr.v1_0.internal.SubstanceAdministrationProposal
import org.opencds.vmr.v1_0.internal.concepts.ImmunizationConcept
import org.opencds.vmr.v1_0.internal.concepts.ObservationCodedValueConcept
import org.opencds.vmr.v1_0.internal.concepts.ObservationFocusConcept
import org.opencds.vmr.v1_0.internal.datatypes.BL
import org.opencds.vmr.v1_0.internal.datatypes.CD
import org.opencds.vmr.v1_0.internal.datatypes.INT
import org.opencds.vmr.v1_0.internal.datatypes.IVLDate
import org.cdsframework.ice.service.DateFactType
import org.cdsframework.ice.service.DiseaseImmunity
import org.cdsframework.ice.service.DoseRule
import org.cdsframework.ice.service.DoseStatus
import org.cdsframework.ice.service.ICEFactTypeFinding
import org.cdsframework.ice.service.LiveVirusFact
import org.cdsframework.ice.service.InconsistentConfigurationException
import org.cdsframework.ice.service.ICELogicHelper
import org.cdsframework.ice.service.PayloadHelper
import org.cdsframework.ice.service.Recommendation
import org.cdsframework.ice.service.RecommendationStatus
import org.cdsframework.ice.service.Schedule
import org.cdsframework.ice.service.Season
import org.cdsframework.ice.service.SeriesRules
import org.cdsframework.ice.service.SeriesDisplaySelection
import org.cdsframework.ice.service.SeriesDisplaySelection.SeriesDisplaySelectionType
import org.cdsframework.ice.service.TargetDose
import org.cdsframework.ice.service.TargetDoseInitializationTracker
import org.cdsframework.ice.service.TargetSeasons
import org.cdsframework.ice.service.TargetSeries
import org.cdsframework.ice.service.TargetSeriesSelection
import org.cdsframework.ice.service.TargetSeriesSelection.SeriesSelectionStatus
import org.cdsframework.ice.supportingdata.BaseDataEvaluationReason
import org.cdsframework.ice.supportingdata.BaseDataRecommendationReason
import org.cdsframework.ice.supportingdatatmp.SupportedFactConcept
import org.cdsframework.ice.util.TimePeriod
import org.cdsframework.ice.util.TimePeriod.DurationType
import org.cdsframework.ice.service.Vaccine
import org.cdsframework.ice.service.VaccineComponent
import accumulate org.cdsframework.ice.service.MinimumDateAccumulateFunction minDate
import accumulate org.cdsframework.ice.service.MaximumDateAccumulateFunction maxDate

// OpenCDS specific
global java.lang.String clientLanguage
global java.lang.String clientTimeZoneOffset
global java.lang.String focalPersonId
global java.util.Date evalTime
global java.util.HashSet<String> assertions
global java.util.HashMap<String,Object> namedObjects

// ICE specific
global java.util.Date patientAgeTimeOfInterest
global org.cdsframework.ice.service.Schedule schedule
global java.lang.Boolean outputEarliestOverdueDates
global java.lang.Boolean doseOverrideFeatureEnabled
global java.lang.Boolean outputSupplementalText
global java.util.List<String> vaccineGroupExclusions
global java.lang.Boolean enableUnsupportedVaccinesGroup
global java.lang.Boolean outputNumberOfDosesRemaining
global java.lang.Boolean disableCovid19DoseNumberReset
global java.lang.String iceVersion

// global org.drools.runtime.KnowledgeContext kcontext


/*****************************************************************************************************************************************************************************/
// 															Initialize Immunization Schedule and other Reference Data
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData.Initialize Immunization Schedule and Supporting Data" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
   	when
		eval(patientAgeTimeOfInterest == null)
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", evalTime);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initialized patientAgeTimeOfInterest" + evalTime);		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData.Initialize Focal Person Id" ruleflow-group "ImmunizationReferenceData"
	no-loop true
	dialect "mvel"
	salience 10
   	when
   		not LiveVirusFact()
   		not TargetSeasons()
		$evaluatedPerson : EvaluatedPerson(isFocalPerson() == true)
		eval(focalPersonId == null || focalPersonId.length() == 0)
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("focalPersonId", $evaluatedPerson.getId());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initialized Focal Person ID" + $evaluatedPerson.getId());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Live Virus Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not (LiveVirusFact())
	then
		String _RULENAME = kcontext.rule.name;		
		LiveVirusFact lvd = new LiveVirusFact();
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Live Virus Fact Object Initialized");
		insert(lvd);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Select Adjuvant Product Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL")
	then
		String _RULENAME = kcontext.rule.name;		
		DateFactType dft = new DateFactType("SELECT_ADJUVANT_PRODUCT_INTERVAL");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Select Adjuvant Product Interval Fact Object Initialized");
		insert(dft);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Dose Override Feature Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not ICEFactTypeFinding(iceResultFinding == "DOSE_OVERRIDE_FEATURE_ENABLED")
		eval(doseOverrideFeatureEnabled != null && doseOverrideFeatureEnabled.booleanValue() == true)
	then
		String _RULENAME = kcontext.rule.name;		
		ICEFactTypeFinding ift = new ICEFactTypeFinding("DOSE_OVERRIDE_FEATURE_ENABLED");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Dose Override Feature Fact Object Initialized");
		insert(ift);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Unsupported Vaccines Group Feature Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not ICEFactTypeFinding(iceResultFinding == "UNSUPPORTED_VACCINES_GROUP_FEATURE_ENABLED")
		eval(enableUnsupportedVaccinesGroup != null && enableUnsupportedVaccinesGroup.booleanValue() == true)
	then
		String _RULENAME = kcontext.rule.name;		
		ICEFactTypeFinding ift = new ICEFactTypeFinding("UNSUPPORTED_VACCINES_GROUP_FEATURE_ENABLED");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Unsupported Vaccines Group Feature Fact Object Initialized");
		insert(ift);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize COVID-19 Sep2023 Dose Number Reset Feature Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not ICEFactTypeFinding(iceResultFinding == "COVID19_SEP2023_DOSE_NUMBER_RESET_DISABLED")
		eval(disableCovid19DoseNumberReset != null && disableCovid19DoseNumberReset.booleanValue() == true)
	then
		String _RULENAME = kcontext.rule.name;		
		ICEFactTypeFinding ift = new ICEFactTypeFinding("COVID19_SEP2023_DOSE_NUMBER_RESET_DISABLED");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "COVID19 Sep2023 Dose Number Reset Feature Fact Object Initialized");
		insert(ift);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ImmunizationReferenceData: Initialize Target Seasons Fact Object" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
	when
		not (TargetSeasons())
	then
		String _RULENAME = kcontext.rule.name;		
		TargetSeasons tseasons = new TargetSeasons(evalTime);
		insert(tseasons);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeasons Fact Object Initialized");
end


///////// ***
// General Design rule... Do not Edit
/////////
rule "InitializeReferenceData: Output Number of Doses Remaining?" ruleflow-group "ImmunizationReferenceData"
	dialect "mvel"
when
	not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue)
	eval(outputNumberOfDosesRemaining != null && outputNumberOfDosesRemaining.booleanValue() == true)
then
	String _RULENAME = kcontext.rule.name;
	ICEFactTypeFinding iftf = new ICEFactTypeFinding(SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue);
	insert(iftf);
	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Output number of doses remaining? Initialized");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Load SeriesRules and TargetDoseInitializationTracker on to Fact List" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "java"
	salience 20
	when
		not SeriesRules()
	then
		String _RULENAME = drools.getRule().getName();
		List<SeriesRules> allCandidates = schedule.getSeriesRulesExcludingVaccineGroupExclusions(vaccineGroupExclusions);
		if (allCandidates != null) {
			Iterator<SeriesRules> iter = allCandidates.iterator();
			if (iter == null) {
				ICELogicHelper.logDRLDebugMessage(_RULENAME, "iter is null");
			}
			while(iter.hasNext()) {
				SeriesRules s = iter.next();
				if (s == null) {
					ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesRules S == null");
				}
				insert(s);
				ICELogicHelper.logDRLDebugMessage(_RULENAME, "Loaded SeriesRules object on the fact list: " + s.getSeriesName());
			}
		}
		TargetDoseInitializationTracker tdit = new TargetDoseInitializationTracker();
		insert(tdit);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Eval Time provided by OpenCDS: " + evalTime.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Insert SeriesRules Seasons into TargetSeasons" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 20
	when
		$tseasons : TargetSeasons()
		$sr : SeriesRules(seasons.size() > 0)
		$season : Season() from $sr.seasons
		not (Season(this == $season))
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.addTargetSeason($season);
		insert($season);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initial season inserted into working memory; TargetSeasons updated with Season: " + $season.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Load Default Seasons on to FactList if not already there" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 15
	when
		$defaultSeason : Season(isDefaultSeason() == true) from schedule.getSeasonsExcludingVaccineGroupExclusions(vaccineGroupExclusions)
		not Season(this == $defaultSeason)
		$tseasons : TargetSeasons()
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.addTargetSeason($defaultSeason);
		insert($defaultSeason);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Initial season inserted into working memory; TargetSeasons updated with Season: " + $defaultSeason.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Update Seasons in Working Memory with Information from TargetSeasons" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 10
	no-loop true
	when
		$season : Season(isDefaultSeason() == false)
		$tseasons : TargetSeasons(containsTargetSeason($season))
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.updateFullySpecifiedSeasonWithOffSeasonDates($season);
		update($season);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Season **updated** in working memory: " + $season.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Update Fully-Specified Seasons in Series with Information from TargetSeasons" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience 5
	no-loop true
	when
		$tseasons : TargetSeasons()
		$sr : SeriesRules(seasons.size() > 0)
		$season : Season(isDefaultSeason() == false) from $sr.seasons
	then
		String _RULENAME = kcontext.rule.name;
		// Adds the Season to the list being tracked by TargetSeasons, and populates off-season end dates for Season (if any)
		$tseasons.updateFullySpecifiedSeasonWithOffSeasonDates($season);
		update($sr);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesRules Season **updated**: " + $season.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "InitializeSeriesAndSeasons: Log TargetSeasons Tracked for this Request" ruleflow-group "InitializeSeriesAndSeasons"
	dialect "mvel"
	salience -1
	when
		$tseasons : TargetSeasons()
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeasons: " + $tseasons.toString());
end

		
/*****************************************************************************************************************************************************************************/
// 															Identify Candidate Series Ruleflow Group - TargetSeries Initialization
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries Custom Rules Invocation" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 110
	when
		$s : SeriesRules()
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoke Custom CandidateSeriesIdentificationRule for SeriesRules: " + $s.getSeriesName());
		setFocus("CandidateSeriesIdentification^customCandidateSeriesIdentificationRule");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries for non-seasonal vaccine groups" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 100
	when
		$s : SeriesRules(seasons == null || seasons.isEmpty())
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)
		$evaluatedPerson : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $evaluatedPerson);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries initialized: " + ts.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries for *Current* Season with Fully-Specified Season Parameters (if defined)" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 100
	when
		$s : SeriesRules(seasons != null, seasons.size() > 0, $vg : vaccineGroup)
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)  
		$season : Season(isDefaultSeason() == false, isDefinedBySeriesTableRules() == true, dateIsApplicableToSeason(evalTime)) from $s.seasons
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason.isDefaultSeason() == false, targetSeason == $season))
		$evaluatedPerson : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(($s.seriesEndAge == null || $s.seriesEndAge != null && TimePeriod.calculateElapsedTimePeriod($birthDate, evalTime, DurationType.DAYS).isLessThanEqualTo($s.seriesEndAge)) &&
			($s.seriesStartAge == null || $s.seriesStartAge != null && TimePeriod.calculateElapsedTimePeriod($birthDate, evalTime, DurationType.DAYS).isGreaterThanEqualTo($s.seriesStartAge)))
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $season, $evaluatedPerson);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize *Current* Season TargetSeries with Default Season Parameters if Current Not Defined for the Vaccine Group" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 90
	when
		$s : SeriesRules($vg : vaccineGroup, seasons != null, seasons.size() > 0)
		$season : Season(isDefaultSeason() == true, dateIsApplicableToSeason(evalTime)) from $s.seasons
		not (Season(isDefaultSeason() == false, vaccineGroup == $vg, dateIsApplicableToSeason(evalTime)))
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)  
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason == $season))
		$evaluatedPerson : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(($s.seriesEndAge == null || $s.seriesEndAge != null && TimePeriod.calculateElapsedTimePeriod($birthDate, evalTime, DurationType.DAYS).isLessThanEqualTo($s.seriesEndAge)) &&
			($s.seriesStartAge == null || $s.seriesStartAge != null	&& TimePeriod.calculateElapsedTimePeriod($birthDate, evalTime, DurationType.DAYS).isGreaterThanEqualTo($s.seriesStartAge)))
		$tseasons : TargetSeasons()
	then
		String _RULENAME = kcontext.rule.name;
		Season fullySpecified = Season.constructFullySpecifiedSeasonFromDefaultSeasonAndDate($season, evalTime);
		$tseasons.addTargetSeason(fullySpecified);
		TargetSeries ts = new TargetSeries($s, schedule, fullySpecified, $evaluatedPerson);
		$s.addFullySpecifiedSeason(fullySpecified);		
		insert(ts);
		insert(fullySpecified);
		update($s);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Updated* TargetSeasons: " + $tseasons.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize *Past* Season TargetSeries when Shots Administered with Fully-Specified Season Parameters if Fully-Specified Season Parameters Defined for the Season" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 80
	when
		ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$s : SeriesRules($vg : vaccineGroup, seasons.size() > 0)
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)
		$season : Season(isDefaultSeason() == false, isDefinedBySeriesTableRules() == true, $season.dateIsApplicableToSeason($shotDate)) from $s.seasons
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason == $season))
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
		$evaluatedPerson : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(($s.seriesEndAge == null || $s.seriesEndAge != null && TimePeriod.calculateElapsedTimePeriod($birthDate, $shotDate, DurationType.DAYS).isLessThanEqualTo($s.seriesEndAge)) &&
			($s.seriesStartAge == null || $s.seriesStartAge != null	&& TimePeriod.calculateElapsedTimePeriod($birthDate, $shotDate, DurationType.DAYS).isGreaterThanEqualTo($s.seriesStartAge)))
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $season, $evaluatedPerson);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize *Past* Season TargetSeries when Shots Administered with Default Season Parameters if No Fully-Specified Season Parameters Defined for the Season" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 70
	when
		ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$s : SeriesRules($vg : vaccineGroup, seasons.size() > 0)
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)
		$season : Season(isDefaultSeason() == true) from $s.seasons
		not Season(isDefaultSeason() == false, vaccineGroup == $vg, dateIsApplicableToSeason($shotDate))
		// Note: for TargetSeries, do not match on series name when there is a default seasons because we do not want a TargetSeries created for the default season if another TargetSeries
		// already handles that season
		not (TargetSeries(targetSeason != null, targetSeason == Season.constructFullySpecifiedSeasonFromDefaultSeasonAndDate($season, $shotDate))) 
		$tseasons : TargetSeasons()
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
		$evaluatedPerson : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(($s.seriesEndAge == null || $s.seriesEndAge != null && TimePeriod.calculateElapsedTimePeriod($birthDate, $shotDate, DurationType.DAYS).isLessThanEqualTo($s.seriesEndAge)) &&
			($s.seriesStartAge == null || $s.seriesStartAge != null	&& TimePeriod.calculateElapsedTimePeriod($birthDate, $shotDate, DurationType.DAYS).isGreaterThanEqualTo($s.seriesStartAge)))
	then
		String _RULENAME = kcontext.rule.name;
		// Create a fully-specified season for this specific year using the default month and day
		Season fullySpecified = Season.constructFullySpecifiedSeasonFromDefaultSeasonAndDate($season, $shotDate);
		$tseasons.addTargetSeason(fullySpecified);
		TargetSeries ts = new TargetSeries($s, schedule, fullySpecified, $evaluatedPerson);
		$s.addFullySpecifiedSeason(fullySpecified);
		insert(ts);
		insert(fullySpecified);
		update($s);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Updated* TargetSeasons: " + $tseasons.toString());		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateSeriesIdentification: Initialize TargetSeries when Shots Administered when One and Only One Season for Vaccine Group exists and no matching Fully-Specified Season Parameters or Default Season Defined for the Season" ruleflow-group "CandidateSeriesIdentification"
	dialect "mvel"
	salience 70
	when
		ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$s : SeriesRules($vg : vaccineGroup, seasons.size() > 0)
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue, associatedSeriesRules == $s)
		not Season(isDefaultSeason() == true, vaccineGroup == $vg)
		// Condition: If there is only one season and above TS does not match it, then we can conclude that there is no seasonal TS that will match
		accumulate($accSeason : Season(vaccineGroup == $vg); $count : count($accSeason); $count == 1)		
		$season : Season(isDefaultSeason() == false, vaccineGroup == $vg, dateIsApplicableToSeason($shotDate) == false)
		not (TargetSeries(seriesName == $s.seriesName, targetSeason != null, targetSeason == $season))
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
		$evaluatedPerson : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(($s.seriesEndAge == null || $s.seriesEndAge != null && TimePeriod.calculateElapsedTimePeriod($birthDate, $shotDate, DurationType.DAYS).isLessThanEqualTo($s.seriesEndAge)) &&
			($s.seriesStartAge == null || $s.seriesStartAge != null	&& TimePeriod.calculateElapsedTimePeriod($birthDate, $shotDate, DurationType.DAYS).isGreaterThanEqualTo($s.seriesStartAge)))
	then
		String _RULENAME = kcontext.rule.name;
		TargetSeries ts = new TargetSeries($s, schedule, $season, $evaluatedPerson);
		insert(ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "*Seasonal* TargetSeries initialized: " + ts.toString());		
end


/*****************************************************************************************************************************************************************************/
// 															Identify Candidate Doses Ruleflow Group - TargetDoses Initialization
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateDosesIdentification: Initialize TargetDose Custom Rules Invocation" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 110
	when
		$i : ImmunizationConcept($ctid : conceptTargetId)
		$sae : SubstanceAdministrationEvent(id == $ctid)
	then
		String _RULENAME = kcontext.rule.name;
		setFocus("CandidateDosesIdentification^customCandidateDosesIdentificationRule");
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoke Custom CandidateSeriesIdentificationRule for SubstanceAdministrationEvent: " + $sae.toString());
end


///////// ***
// General Design rule... Do not Edit
// For each series that was identified as relevant, initialize each TargetSeries with TargetDoses. TargetDoses are created/initialized for all
// shots administered where the vaccine is used by the vaccine group, even if the Series itself does not permit that kind of vaccine to be used
// in any of its doses. This is so that shots administered with a vaccine present in the Vaccine Group will still be evaluated with a decision 
// should that TargetSeries be selected from which to forecast.
///////// ***
rule "CandidateDosesIdentification: Initialize TargetDose in *Non-Seasonal* TargetSeries" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 50
	no-loop true
	when
		$i : ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode, $occ != "ICE316")
		$sae : SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$ts : TargetSeries($vg : vaccineGroup, targetSeasonExists() == false, $tsid : targetSeriesIdentifier)
		// Condition: the tracking map must either NOT contain a key with this SubstanceAdministrationEvent and this OpenCDS concept, or if it does contain 
		// this SubstanceAdministrationEvent and this OpenCDS concept, that the value of this key is the same as concept code as that of the vaccine group's. 
		// Furthermore, if there exists a vaccine component within this shot administered that has not been initialized in this series for this vaccine group, 
		$tdit : TargetDoseInitializationTracker(shotAdministeredIsEligibleForInclusionInTargetSeries($i, $vg, $sae, $ts, schedule.getVaccineByCdsConceptValue($occ)) == true)
		// Condition: the administered vaccine targets one or more of the diseases handled for this vaccine group
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
			// && $tdit.allTargetDosesHaveBeenInitializedInSeries($sae, schedule.getVaccineByCdsConceptValue($occ), $ts) == false)
	then
		String _RULENAME = kcontext.rule.name;
		Vaccine administeredVaccine = schedule.getVaccineByCdsConceptValue($i.getOpenCdsConceptCode());
		for (TargetDose initializedTargetDose : $tdit.addTargetDoseInitialization(administeredVaccine, $sae, $ts, schedule)) {
			insert(initializedTargetDose);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose initialized in TargetSeries " + $ts.seriesName + " ; vaccine: " + $occ + "; vaccine group " + $vg + "; shotdate " + $shotDate);
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, "completed");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateDosesIdentification: Initialize TargetDose in *Seasonal* TargetSeries" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 50
	no-loop true
	when
		$i : ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		$sae : SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$ts : TargetSeries($vg : vaccineGroup, targetSeason != null && targetSeason.dateIsApplicableToSeason($shotDate), $tsid : targetSeriesIdentifier)
		// Condition: the tracking map must either NOT contain a key with this SubstanceAdministrationEvent and this OpenCDS concept, or if it does contain 
		// this SubstanceAdministrationEvent and this OpenCDS concept, that the value of this key is the same as concept code as that of the vaccine group's. 
		// Furthermore, if there exists a vaccine component within this shot administered that has not been initialized in this series for this vaccine group, 
		$tdit : TargetDoseInitializationTracker(shotAdministeredIsEligibleForInclusionInTargetSeries($i, $vg, $sae, $ts, schedule.getVaccineByCdsConceptValue($occ)) == true)
		// Condition: the administered vaccine targets one or more of the diseases handled for this vaccine group
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
	then
		String _RULENAME = kcontext.rule.name;
		Vaccine administeredVaccine = schedule.getVaccineByCdsConceptValue($i.getOpenCdsConceptCode());
		for (TargetDose initializedTargetDose : $tdit.addTargetDoseInitialization(administeredVaccine, $sae, $ts, schedule)) {
			insert(initializedTargetDose);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose initialized in TargetSeries " + $ts.seriesName + " ; vaccine: " + $occ + "; vaccine group " + $vg + "; shotdate " + $shotDate);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, "completed");	
end

///////// ***
// General Design rule... Do not Edit
// Seasonal TargetDose Outlier Initialization Rule: TargetDose initialization rule for H1N1 or other "seasonal" series that have only one defined season and no default season 
// E.G. - Since there is only one season for H1N1 and no default season, any shots that come in will get associated with the existing TargetSeries even if it falls outside 
// of its season date. NOTE: ICE Schedule validation does not permit multiple seasons in a vaccine group if there is no default season defined.
///////// ***
rule "CandidateDosesIdentification: Initialize Outlier TargetDose into Existing TargetSeries" ruleflow-group "CandidateDosesIdentification"
	dialect "mvel"
	salience 50
	no-loop true
	when
		$i : ImmunizationConcept($ctid : conceptTargetId, $occ : openCdsConceptCode)
		$sae : SubstanceAdministrationEvent(id == $ctid, $shotDate : ICELogicHelper.extractSingularDateValueFromIVLDate(administrationTimeInterval))
		$ts : TargetSeries($vg : vaccineGroup, targetSeason != null && targetSeason.dateIsApplicableToSeason($shotDate) == false, $tsid : targetSeriesIdentifier)
		// Condition: there is no default season for this vaccine group
		not Season(vaccineGroup == $vg, isDefaultSeason() == true)
		// Condition: If there is only one season and above TS does not match it, then we can conclude that there is no seasonal TS that will match
		accumulate($accSeason : Season(vaccineGroup == $vg); $count : count($accSeason); $count == 1)
		// Condition: the tracking map must either NOT contain a key with this SubstanceAdministrationEvent and this OpenCDS concept, or if it does contain 
		// this SubstanceAdministrationEvent and this OpenCDS concept, that the value of this key is the same as concept code as that of the vaccine group's. 
		// Furthermore, if there exists a vaccine component within this shot administered that has not been initialized in this series for this vaccine group, 
		$tdit : TargetDoseInitializationTracker(shotAdministeredIsEligibleForInclusionInTargetSeries($i, $vg, $sae, $ts, schedule.getVaccineByCdsConceptValue($occ)) == true)
		// Condition: the administered vaccine targets one or more of the diseases handled for this vaccine group
		eval(schedule.vaccineTargetsOneOrMoreOfSpecifiedDiseases(schedule.getVaccineByCdsConceptValue($occ), schedule.getDiseasesTargetedByVaccineGroup($vg)) == true)
	then
		String _RULENAME = kcontext.rule.name;
		Vaccine administeredVaccine = schedule.getVaccineByCdsConceptValue($i.getOpenCdsConceptCode());
		for (TargetDose initializedTargetDose : $tdit.addTargetDoseInitialization(administeredVaccine, $sae, $ts, schedule, true)) {
			insert(initializedTargetDose);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose initialized in TargetSeries " + $ts.seriesName + " ; vaccine: " + $occ + "; vaccine group " + $vg + "; shotdate " + $shotDate);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, "completed; TargetSeries " + $ts);	
end


/*****************************************************************************************************************************************************************************/
// 															Candidate Doses Revisions Ruleflow Group
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "CandidateDosesRevisions: Initialize Series Aggregation Custom Rules Invocation" ruleflow-group "CandidateDosesRevisions"
	dialect "mvel"
	when
		exists ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._CANDIDATE_SERIES_IDENTIFICATION_DEFAULT_RULE_OVERRIDE.conceptCodeValue)
		/////// $s : SeriesRules(this == $iftf.associatedSeriesRules)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoke Custom Candidate Dose Revisions for All Series");
		setFocus("CandidateDosesRevisions^customCandidateDoseRevisionRule");
end


/*****************************************************************************************************************************************************************************/
// 															Record Disease Immunity
/*****************************************************************************************************************************************************************************/
 
// If the patient has immunity to a disease and it is on or after the immunity date, mark the patient as immune to the disease in the series
rule "DiseaseImmunityRecord.MarkImmuneToDiseaseIfOnOrAfterImmunityDate" ruleflow-group "DiseaseImmunityRecord"
	dialect "mvel"
	no-loop
	when
		$di : DiseaseImmunity($disease : disease, $immunityDate : dateOfImmunity <= evalTime)
		$targetSeries : TargetSeries($disease memberOf diseasesSupportedByThisSeries, targetSeason == null || targetSeason != null && targetSeason.fullySpecifiedSeasonStartDate.toDate() <= evalTime)
	then
		String _RULENAME = kcontext.rule.name;
		$targetSeries.markImmunityToSpecifiedDisease($disease, $immunityDate);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "for disease " + $disease + ", immunity date " + $immunityDate + " in TargetSeries " + $targetSeries.getSeriesName());
		update($targetSeries);
end



/*****************************************************************************************************************************************************************************/
// 															Evaluation of doses
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateNonSeasonalSeriesWhenNoTargetDosesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$ts : TargetSeries(targetSeasonExists() == false, numberOfShotsAdministeredInSeries == 0, isHistoryEvaluationInitiated() == false)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $ts);
		setFocus("HistoryEvaluation^customEvaluationRule");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setNonSeasonalNextTargetDoseNonNOSInSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == false, associatedTargetSeries.targetSeasonExists() == false)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		modify($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit - for same day shots, only select NOS shot for evaluation after all other non-NOS shots have been evaluated for this series
///////// ***
rule "HistoryEvaluation.setNonSeasonalNextTargetDoseNOSInSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == true, associatedTargetSeries.targetSeasonExists() == false)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, uniqueId != $td.uniqueId, administrationDate == $td.administrationDate, vaccineComponent.isUnspecifiedFormulation() == false)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		modify($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateSeasonalSeriesWhenNoTargetDosesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$ts : TargetSeries(numberOfShotsAdministeredInSeries == 0, isHistoryEvaluationInitiated() == false, targetSeasonExists() == true)
		not TargetSeries(isHistoryEvaluationInitiated() == false, targetSeasonExists() == true, seasonStartDate < $ts.seasonStartDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries != $ts, associatedTargetSeries.targetSeasonExists() == true, associatedTargetSeries.seasonStartDate < $ts.seasonStartDate)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $ts);
		setFocus("HistoryEvaluation^customEvaluationRule");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setNextSeasonalTargetDoseNonNOSInSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$ts : TargetSeries(targetSeasonExists() == true)
		exists TargetDose(associatedVaccineGroup == $ts.vaccineGroup, status == DoseStatus.EVALUATION_NOT_STARTED) from $ts.targetDoses
		not TargetSeries(isHistoryEvaluationInitiated() == false, targetSeasonExists() == true, seasonStartDate < $ts.seasonStartDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries != $ts, associatedTargetSeries.targetSeasonExists() == true, associatedTargetSeries.seasonStartDate < $ts.seasonStartDate)
		$td : TargetDose(associatedTargetSeries == $ts, status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == false)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		modify($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit - for same day shots, only select NOS shot for evaluation after all other non-NOS shots have been evaluated for this series
///////// ***
rule "HistoryEvaluation.setNextSeasonalTargetDoseNOSInSeriesForEvaluation" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$ts : TargetSeries(targetSeasonExists() == true)
		exists TargetDose(associatedVaccineGroup == $ts.vaccineGroup, status == DoseStatus.EVALUATION_NOT_STARTED) from $ts.targetDoses
		not TargetSeries(isHistoryEvaluationInitiated() == false, targetSeasonExists() == true, seasonStartDate < $ts.seasonStartDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries != $ts, associatedTargetSeries.targetSeasonExists() == true, associatedTargetSeries.seasonStartDate < $ts.seasonStartDate)
		$td : TargetDose(associatedTargetSeries == $ts, status == DoseStatus.EVALUATION_NOT_STARTED, vaccineComponent.isUnspecifiedFormulation() == true)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, uniqueId != $td.uniqueId, administrationDate == $td.administrationDate, vaccineComponent.isUnspecifiedFormulation() == false)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS);
		}
		modify($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// General Design and Supplemental Series Table rule... modifying this rule not suggested;
// "Dose Override". If the Dose Override feature is enabled and caller specifies a shot should be treated as Valid or Invalid, processed this shot before other shots on the same day.
// Thus, the higher salience. In addition, all other rules related to evaluation logic are skipped for this dose override shot.
/////////
rule "HistoryEvaluation: If Dose Override Specified, set Dose Evaluation Status Accordingly and Bypass Evaluation Logic" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 10
	when
		exists ICEFactTypeFinding(iceResultFinding == "DOSE_OVERRIDE_FEATURE_ENABLED")
		not TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS || status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$td : TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED)
		not TargetDose(status == DoseStatus.EVALUATION_NOT_STARTED, associatedTargetSeries == $td.associatedTargetSeries, administrationDate < $td.administrationDate)
		$sae : SubstanceAdministrationEvent(id == $td.doseId, isValid != null)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
		$tdsEvaluated : List() from accumulate($tdacc : TargetDose(associatedTargetSeries == $td.associatedTargetSeries, hasBeenEvaluated == true), collectList($tdacc))
	then
		String _RULENAME = kcontext.rule.name;
		DoseStatus evaluationStatus = $sae.getIsValid().isValue() == true ? DoseStatus.VALID : DoseStatus.INVALID;
		String evaluationStatusReason = $sae.getIsValid().isValue() == true ? BaseDataEvaluationReason._DOSE_OVERRIDE_VALID.getCdsListItemName(): BaseDataEvaluationReason._DOSE_OVERRIDE_INVALID.getCdsListItemName();
		modify ($td) {
			setDoseStatusOverridden(true),
			setIsPrimarySeriesShot(! $ts.isSeriesComplete()),
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			setAdministeredShotNumberInSeries($tdsEvaluated.size()+1),
			setStatus(evaluationStatus),	
			addValidReason(evaluationStatusReason);
		}
		modify($ts) {
			setHistoryEvaluationInitiated(true);
		}
		ICELogicHelper.logDRLDebugMessage(kcontext.rule.name, "Dose Override Check Complete for TargetDose " + $td + " in TargetSeries " + $ts);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation: Determine & Record if the Selected TargetDose to be Evaluated is a Primary Shot of the Series, and Initialize the TargetDose Shot Number and Dose Number" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$td : TargetDose(status == DoseStatus.PRIMARY_SHOT_DETERMINATION_IN_PROCESS)
		$tdsEvaluated : List() from accumulate($tdacc : TargetDose(associatedTargetSeries == $td.associatedTargetSeries, hasBeenEvaluated == true), collectList($tdacc))	
	then
		String _RULENAME = kcontext.rule.name;
		int tddosenumber = $td.getAssociatedTargetSeries().determineDoseNumberInSeries();
		int tdshotnumber = $tdsEvaluated.size()+1;
		boolean isSeriesComplete = $td.getAssociatedTargetSeries().isSeriesComplete();
		boolean isSeriesNotComplete = ! isSeriesComplete;
		modify($td) {
			setStatus(DoseStatus.EVALUATION_IN_PROCESS),
			setIsPrimarySeriesShot(isSeriesNotComplete),
			setDoseNumberInSeries(tddosenumber),
			setAdministeredShotNumberInSeries(tdshotnumber);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.getAssociatedTargetSeries());
		setFocus("HistoryEvaluation^makeNoteOfDuplicateShotSameDayIfAny");
		setFocus("HistoryEvaluation^customMakeNoteOfDuplicateShotSameDayIfAny");		
		setFocus("HistoryEvaluation^preEvaluationValidation");
end


///////// ***
// General Design and Supplemental Series Table rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If the vaccine is administered after the immunity date recorded for *all* diseases targeted by the vaccine, mark the shot ACCEPTED. 
// Mark the status of the shot as EVALUATION_COMPLETE, to prevent other rules from overriding this ACCEPTED decision
//////// ***
rule "HistoryEvaluation: Check if Shot should be marked Accepted and Series Complete if Administered On or After Immunity Date"
	dialect "mvel"
	agenda-group "HistoryEvaluation^preEvaluationValidation" 
	when
		$targetDose : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $diseasesTargetedByThisDose : vaccineComponent.allDiseasesTargetedForImmunity, $doseAdministrationDate : administrationDate)
		$targetSeries : TargetSeries(this == $targetDose.associatedTargetSeries)
		$diseaseImmunityList : List(size == $diseasesTargetedByThisDose.size()) from 
			accumulate($di : DiseaseImmunity($d : getDisease(), getDateOfImmunity() <= $doseAdministrationDate, $r : getImmunityReason(), disease memberOf $diseasesTargetedByThisDose), collectList($di))
	then
		Iterator dilIter = $diseaseImmunityList.iterator();
		while (dilIter.hasNext()) {
			DiseaseImmunity diConsequence = (DiseaseImmunity) dilIter.next();
			$targetDose.addAcceptedReason(diConsequence.getEvaluationReasonResult());				
		}
		modify ($targetDose) { setStatus(DoseStatus.EVALUATION_COMPLETE) } ///// Note for docs: marking this dose valid, so we mark evaluation complete override all other "negative check" rules
		ICELogicHelper.logDRLDebugMessage(drools.getRule().getName(), "Marking Evaluation Complete for TargetDose " + $targetDose.toString() + " in TargetSeries " + $targetSeries .getSeriesName());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "Duplicate Shot/Same Day (Abstract): 2 shots administered on the same day"
	dialect "mvel"
	agenda-group "HistoryEvaluation^makeNoteOfDuplicateShotSameDayIfAny"
	no-loop true
	when
		$td: TargetDose(isPreEvaluationCheckCompleted() == false, status == DoseStatus.EVALUATION_IN_PROCESS, $administrationDate : administrationDate, $tdAdministeredShotNumber : administeredShotNumberInSeries, 
			$doseNumber : doseNumberInSeries)
		$tdprev : TargetDose(administrationDate == $administrationDate, hasBeenEvaluated == true, administeredShotNumberInSeries == $tdAdministeredShotNumber-1, $tdprevDoseNumber: doseNumberInSeries, $tdprevDoseNumber <= $doseNumber)
		$targetSeries : TargetSeries(this == $td.associatedTargetSeries, this == $tdprev.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $targetSeries);
end


///////// ***
// General Design rule... Do not Edit
// If this shot is a duplicate shot/same day shot as another shot in the series, mark its dose number the same as the previous shot (only one of the duplicate shot can be a valid dose)
///////// ***
rule "Duplicate Shot/Same Day: If this is a duplicate shot/same day, mark the dose number of the shot being evaluated as equal to prior shots administered on the same date; Invoke custom evaluation rules" 
		extends "Duplicate Shot/Same Day (Abstract): 2 shots administered on the same day"
	dialect "mvel"
	agenda-group "HistoryEvaluation^makeNoteOfDuplicateShotSameDayIfAny"
	no-loop true
	when
		eval(// $tdprev.isShotIgnored() == false || 
			$tdprev.isShotIgnored() == false && 
			($doseNumber > $targetSeries.getSeriesRules().getNumberOfDosesInSeries() && $targetSeries.getSeriesRules().recurringDosesOccurAfterSeriesComplete() == false) || 
			($tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber) != null && 
			$tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval() != null &&
			! $tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval().isEqualTo(new TimePeriod(0, DurationType.DAYS))))
	then
		String _RULENAME = kcontext.rule.name;
		modify ($td) {
			setDoseNumberInSeries($tdprevDoseNumber), 
			setPreEvaluationCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $targetSeries);
		setFocus("HistoryEvaluation^customEvaluationRule");
end


///////// ***
// General Design rule... Do not Edit
// If this shot is a duplicate shot/same day shot as another shot in the series, but interval is 0 days between them so latter shots' dose number is not set to same as previous shot
///////// ***
rule "Duplicate Shot/Same Day: duplicate shots on same day where interval is 0 days are not marked with the same dose number; Invoke custom evaluation rules" 
		extends "Duplicate Shot/Same Day (Abstract): 2 shots administered on the same day"
	dialect "mvel"
	agenda-group "HistoryEvaluation^makeNoteOfDuplicateShotSameDayIfAny"
	no-loop true
	when
		eval($tdprev.isShotIgnored() == true || 
			(($doseNumber <= $targetSeries.getSeriesRules().getNumberOfDosesInSeries() || $targetSeries.getSeriesRules().recurringDosesOccurAfterSeriesComplete() == true) &&
			($tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber) == null || 
			$tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval() == null ||
			$tdprev.getAssociatedTargetSeries().obtainDoseRuleForSeriesByDoseNumber($tdprevDoseNumber).getAbsoluteMinimumInterval().isEqualTo(new TimePeriod(0, DurationType.DAYS)))))
	then
		String _RULENAME = kcontext.rule.name;
		modify ($td) {
			setPreEvaluationCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $targetSeries);
		setFocus("HistoryEvaluation^customEvaluationRule");
end


///////// ***
// General Design rule... Do not Edit
// If this shot is not a duplicate shot/same day shot as another shot in the series, just move on to the custom rules
///////// ***
rule "Not Duplicate Shot/Same Day: No duplicate shots to shot being evaluated; Invoke custom evaluation rules"
	dialect "mvel"
	agenda-group "HistoryEvaluation^makeNoteOfDuplicateShotSameDayIfAny"
	when
		$td: TargetDose(isPreEvaluationCheckCompleted() == false, status == DoseStatus.EVALUATION_IN_PROCESS)
		not TargetDose(this != $td, administrationDate == $td.administrationDate, administeredShotNumberInSeries < $td.administeredShotNumberInSeries, associatedTargetSeries == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($td) {
			setPreEvaluationCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.associatedTargetSeries);
		setFocus("HistoryEvaluation^customEvaluationRule");	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusInvalid" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 10
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty == false, $ts : associatedTargetSeries) 
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setDoseNumberCount($td.associatedTargetSeries.determineNumberOfDosesAdministeredInSeries()+1),
			setStatus(DoseStatus.INVALID),
			addDoseRuleProcessed(_RULENAME);
		}
		update($ts);
		// setStatus() above also sets hasBeenEvaluated to true
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.associatedTargetSeries);
		setFocus("HistoryEvaluation^postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusNotEvaluated" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 10
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty, notEvaluatedReasons.empty == false, $ts : associatedTargetSeries) 
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setDoseNumberCount($td.associatedTargetSeries.determineNumberOfDosesAdministeredInSeries()+1),
			setStatus(DoseStatus.NOT_EVALUATED),
			addDoseRuleProcessed(_RULENAME);
		}
		// setStatus() above also sets hasBeenEvaluated to true
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.associatedTargetSeries);
		setFocus("HistoryEvaluation^postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusAccepted" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 10
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty, notEvaluatedReasons.empty, acceptedReasons.empty == false)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			setStatus(DoseStatus.ACCEPTED),
			addDoseRuleProcessed(_RULENAME);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.associatedTargetSeries);
		setFocus("HistoryEvaluation^postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.setDoseEvaluationStatusValid" ruleflow-group "HistoryEvaluation"
	dialect "java"
	salience 10
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_COMPLETE, invalidReasons.empty, acceptedReasons.empty, notEvaluatedReasons.empty)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
	then
		String _RULENAME = drools.getRule().getName();
		modify($td) {
			setDoseNumberCount($ts.determineNumberOfDosesAdministeredInSeries()+1),
			addDoseRuleProcessed(_RULENAME),
			setStatus(DoseStatus.VALID);
		}
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
		drools.setFocus("HistoryEvaluation^postEvaluationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "HistoryEvaluation.denoteDoseReadyForFinalEvaluationStatus" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 60
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS)
	then
		String _RULENAME = kcontext.rule.name;
		modify($td) {
			setStatus(DoseStatus.EVALUATION_COMPLETE);
		}
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.associatedTargetSeries.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $td.associatedTargetSeries);
end


///////// ***
// Supplemental Series Table rule... modifying this rule not suggested
///////// ***
rule "HistoryEvaluation.markExtraneousDosesAcceptedIfCompleteForAllDiseaseTargetedByThisDose" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "extraDoseCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $doseNumber : doseNumberInSeries) 
		$ts : TargetSeries(this == $td.associatedTargetSeries, isSeriesComplete() == true || seriesRules.numberOfDosesInSeries < determineDoseNumberInSeriesForDiseasesTargetedByThisDose($td)) 
	then
		String _RULENAME = kcontext.rule.name;
		$td.addAcceptedReason(BaseDataEvaluationReason._EXTRA_DOSE_EVALUATION_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkIsAllowableVaccine" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "allowableVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $vaccine : administeredVaccine, $doseNumber : doseNumberInSeries)
		$ts : TargetSeries(this == $td.associatedTargetSeries, $doseNumber <= seriesRules.numberOfDosesInSeries, seriesRules.isAllowableVaccineForDoseRule($vaccine, $doseNumber) == false) 
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef);
		$td.addInvalidReason(BaseDataEvaluationReason._VACCINE_NOT_ALLOWED_FOR_THIS_DOSE.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkMinimumAgeVaccine" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "minimumAgeVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $adminage : vaccineComponent.validMinimumAgeForUse != null, $tdVaccineComponent : vaccineComponent)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
		not DoseRule(encompassingSeriesRules == $ts.seriesRules, doseNumber == $td.doseNumberInSeries, getAllowableVaccineMinimumAge($tdVaccineComponent) != null) from $ts.seriesRules.seriesDoseRules
		$person : EvaluatedPerson()
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($person.getDemographics().getBirthTime(), $td.getAdministrationDate(), $adminage) < 0)
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef);
		$td.addInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_AGE_VACCINE_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkMinimumAgeVaccineDoseRule" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "minimumAgeVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $tdVaccineComponent : vaccineComponent)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
		$dr : DoseRule(encompassingSeriesRules == $ts.seriesRules, doseNumber == $td.doseNumberInSeries, getAllowableVaccineMinimumAge($tdVaccineComponent) != null) from $ts.seriesRules.seriesDoseRules
		$person : EvaluatedPerson()
		eval(! TimePeriod.isTimePeriodANegativeDuration($dr.getAllowableVaccineMinimumAge($tdVaccineComponent).getTimePeriodStringRepresentation()) && 
			TimePeriod.compareElapsedTimePeriodToDateRange($person.getDemographics().getBirthTime(), $td.getAdministrationDate(), $dr.getAllowableVaccineMinimumAge($tdVaccineComponent)) < 0)
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef);
		$td.addInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_AGE_VACCINE_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);	
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkMaximumAgeVaccine" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "maximumAgeVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $adminage : vaccineComponent.validMaximumAgeForUse != null, $tdVaccineComponent : vaccineComponent)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
		not DoseRule(encompassingSeriesRules == $ts.seriesRules, doseNumber == $td.doseNumberInSeries, getAllowableVaccineMaximumAge($tdVaccineComponent) != null) from $ts.seriesRules.seriesDoseRules
		$person : EvaluatedPerson()
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($person.getDemographics().getBirthTime(), $td.getAdministrationDate(), $adminage) > 0)
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef)		
		$td.addInvalidReason(BaseDataEvaluationReason._ABOVE_MAXIMUM_AGE_VACCINE.getCdsListItemName());
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.checkMaximumAgeVaccineDoseRuleDoseRule" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	salience 100
	activation-group "maximumAgeVaccineCheck"
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $tdVaccineComponent : vaccineComponent)
		$ts : TargetSeries(this == $td.associatedTargetSeries)
		$dr : DoseRule(encompassingSeriesRules == $ts.seriesRules, doseNumber == $td.doseNumberInSeries, getAllowableVaccineMaximumAge($tdVaccineComponent) != null) from $ts.seriesRules.seriesDoseRules
		$person : EvaluatedPerson()
		eval(! TimePeriod.isTimePeriodANegativeDuration($dr.getAllowableVaccineMaximumAge($tdVaccineComponent).getTimePeriodStringRepresentation()) && 
			TimePeriod.compareElapsedTimePeriodToDateRange($person.getDemographics().getBirthTime(), $td.getAdministrationDate(), $dr.getAllowableVaccineMaximumAge($tdVaccineComponent)) > 0)
	then
		String _RULENAME = kcontext.rule.name;
		ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._INVALID_VACCINE.getConceptCodeValue(), $td);
		insert(hef)		
		$td.addInvalidReason(BaseDataEvaluationReason._ABOVE_MAXIMUM_AGE_VACCINE.getCdsListItemName());
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateVaccineGroupMaximumAge" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseMaximumAgeCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $doseNumber : doseNumberInSeries) 
		$ts : TargetSeries(this == $td.associatedTargetSeries, seriesRules.numberOfDosesInSeries >= $doseNumber)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMaximumAgeandRecordReason($person.demographics.birthTime, $td);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._ABOVE_MAXIMUM_AGE_EVALUATION_REASON.getCdsListItemName()) || 
			$td.containsInvalidReason(BaseDataEvaluationReason._INVALID_AGE_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._ABOVE_MAXIMUM_AGE.getConceptCodeValue(), $td);
			insert(hef)				
		}
		$td.addDoseRuleProcessed(_RULENAME);
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end 


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateVaccineGroupMinimumAge" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseAgeCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $doseNumber : doseNumberInSeries) 
		$ts : TargetSeries(this == $td.associatedTargetSeries, seriesRules.numberOfDosesInSeries >= $doseNumber)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMinimumAgeandRecordReason($person.demographics.birthTime, $td);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_AGE_EVALUATION_REASON.getCdsListItemName()) || 
			$td.containsInvalidReason(BaseDataEvaluationReason._INVALID_AGE_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._BELOW_MINIMUM_AGE.getConceptCodeValue(), $td);
			insert(hef)				
		}
		$td.addDoseRuleProcessed(_RULENAME);
		// ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts.seriesName);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end 


///////// ***
// Series table rule... Do not Edit
///////// ***
rule "HistoryEvaluation.evaluateVaccineGroupMinimumInterval" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseIntervalCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $admindose: administeredShotNumberInSeries >= 2, $doseNumber : doseNumberInSeries, $tddate : administrationDate, 
			$tdAssociatedTargetSeries : associatedTargetSeries)
		$tdprev : TargetDose(associatedTargetSeries == $tdAssociatedTargetSeries, administeredShotNumberInSeries < $admindose, administrationDate < $tddate, 
			isShotIgnored() == false, $tdprevdate : administrationDate)
		not TargetDose(associatedTargetSeries == $tdAssociatedTargetSeries, administrationDate > $tdprevdate, administrationDate < $tddate, isShotIgnored() == false)
		$ts : TargetSeries(this == $td.associatedTargetSeries, this == $tdprev.associatedTargetSeries, seriesRules.numberOfDosesInSeries >= $doseNumber)
		not (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._BELOW_MINIMUM_AGE.conceptCodeValue, associatedTargetDose == $tdprev, associatedTargetDose.doseNumberInSeries == 1, 
			associatedTargetDose.administeredShotNumberInSeries == $admindose-1))
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMinimumIntervalAndRecordReason($td, $tdprev);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_INTERVAL_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._BELOW_MINIMUM_INTERVAL.getConceptCodeValue(), $td);
			insert(hef)				
		}
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);
end


///////// ***
// Series table rule... Do not Edit
///////// ***
rule "HistoryEvaluation: Evaluate minimum interval between first shot in seasonal series and most recent shot from a prior season" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseIntervalCheckFromPreviousSeason"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, administeredShotNumberInSeries == 1, $doseNumber : doseNumberInSeries)
		$ts : TargetSeries(this == $td.associatedTargetSeries, seriesRules.numberOfDosesInSeries >= $doseNumber, targetSeason != null, $tseason : targetSeason,	$vaccineGroup : vaccineGroup, $tsid : targetSeriesIdentifier)
		$tsprev : TargetSeries(vaccineGroup == $vaccineGroup, targetDoses.size() > 0, targetSeriesIdentifier != $tsid, targetSeason != null, $tseasonPrev : targetSeason, targetSeason.getFullySpecifiedSeasonStartDate().isBefore($tseason.getFullySpecifiedSeasonStartDate()))
		not TargetSeries(targetSeriesIdentifier != $tsprev.targetSeriesIdentifier, targetSeason != null, vaccineGroup == $vaccineGroup,	targetDoses.size() > 0, targetSeason.fullySpecifiedSeasonStartDate.isAfter($tseasonPrev.getFullySpecifiedSeasonStartDate()) && 
			targetSeason.fullySpecifiedSeasonStartDate.isBefore($tseason.getFullySpecifiedSeasonStartDate()))
		$lastFromPrev: TargetDose(associatedTargetSeries == $tsprev, isShotIgnored() == false, $shotNumber: administeredShotNumberInSeries)
		not TargetDose(associatedTargetSeries == $tsprev, isShotIgnored() == false, administeredShotNumberInSeries > $shotNumber)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.evaluateVaccineGroupMinimumIntervalAndRecordReason($td, $lastFromPrev);
		if ($td.containsInvalidReason(BaseDataEvaluationReason._BELOW_MINIMUM_INTERVAL_EVALUATION_REASON.getCdsListItemName())) {
			ICEFactTypeFinding hef = new ICEFactTypeFinding(SupportedFactConcept._BELOW_MINIMUM_INTERVAL.getConceptCodeValue(), $td);
			insert(hef);
		}
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in " + $ts + "; Prior Dose " + $lastFromPrev + " in " + $tsprev);
end


///////// ***
// Series table rule... Do not Edit
///////// ***
rule "HistoryEvaluation: Evaluate Shot as Invalid if it is not between the Season Start and End Dates" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	activation-group "doseInSeasonCheck"
	salience 100
	when
		$td : TargetDose(status == DoseStatus.EVALUATION_IN_PROCESS, $administrationDate : administrationDate)
		$ts : TargetSeries(this == $td.associatedTargetSeries, targetSeason != null, targetSeason.dateIsApplicableToSeason($administrationDate, false) == false)
	then
		String _RULENAME = kcontext.rule.name;
		$td.addInvalidReason(BaseDataEvaluationReason._OUTSIDE_SEASON_REASON.getCdsListItemName());
		$td.addDoseRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, $td.toString() + " in TargetSeries " + $ts);				
end


///////// ***
// Supplemental Series Table rule... Do not Edit
// If all shots in the TargetSeries have been evaluated and the patient has reached immunity for every disease handled by this Series, mark in the TargetSeries that
// the patient is immune to all diseases.
///////// ***
rule "HistoryEvaluation: If all shots have been evaluated, take immunity dates into account to determine if series is complete" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$ts : TargetSeries(isSeriesComplete() == false)
		not TargetDose(hasBeenEvaluated == false) from $ts.targetDoses
		$diseaseImmunitiesRecordedForTargetSeries : List(size > 0) from accumulate(DiseaseImmunity($diseaseacc : disease memberOf $ts.diseasesSupportedByThisSeries), collectList($diseaseacc))
		TargetSeries(this == $ts, $numberOfDosesInSeries : seriesRules.numberOfDosesInSeries, $diseasesOfInterest : allEvaluationValidityCountsByDisease.keySet())
		eval($diseasesOfInterest.removeAll($diseaseImmunitiesRecordedForTargetSeries) == true && $ts.determineEffectiveNumberOfDosesInSeriesForSpecifiedDiseasesOnly($diseasesOfInterest) == $ts.seriesRules.numberOfDosesInSeries)
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setSeriesComplete(true);
		}
		for (String diseaseImmunityRecorded : $diseaseImmunitiesRecordedForTargetSeries) {
			ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $ts + "; Disease Immunity Recorded: " + diseaseImmunityRecorded);
		} 
		Set lDiseasesOfInterest = $ts.getAllEvaluationValidityCountsByDisease.keySet();
		lDiseasesOfInterest.removeAll($diseaseImmunitiesRecordedForTargetSeries);
		for (String disease : lDiseasesOfInterest) {
			ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $ts + "; disease of interest: " + disease);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $ts + "; determineEffective..." + $ts.determineEffectiveNumberOfDosesInSeriesForSpecifiedDiseasesOnly(lDiseasesOfInterest));
end
 

///////// ***
// Supplemental Series Table rule... Do not Edit
// If all shots in the TargetSeries have been evaluated and the patient has reached immunity for every disease handled by this Series, mark in the TargetSeries that
// the patient is immune to all diseases.
///////// ***
rule "HistoryEvaluation: Set Disease Immunity Flag in Series to True if Immune to All Diseases Tracked by this Series as of the Evaluation Time" ruleflow-group "HistoryEvaluation"
	dialect "mvel"
	when
		$ts : TargetSeries($diseasesSupportedByThisSeries : diseasesSupportedByThisSeries, isImmunityToAllDiseasesRecorded() == false)
		not TargetDose(hasBeenEvaluated == false) from $ts.targetDoses
		Set(size == $diseasesSupportedByThisSeries.size()) from accumulate($di : DiseaseImmunity(dateOfImmunity <= evalTime, disease memberOf $diseasesSupportedByThisSeries), collectSet($di.disease))
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setImmunityToAllDiseasesRecorded(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries immunityToAllDiseasesRecorded set to true for " + $ts); 
end


/*****************************************************************************************************************************************************************************/
// 																Series Selection 
/*****************************************************************************************************************************************************************************/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Insert TargetSeriesSelection (Tracker) on to the Fact List for each Vaccine Group/Season" ruleflow-group "SeriesSelection"
	dialect "java"
	salience 10
	when
		$tseries : TargetSeries($vg : getVaccineGroup(), $tseason : getTargetSeason())
		not (TargetSeriesSelection(getSeriesSelectionVaccineGroup() == $vg, getSeriesSelectionSeason() == $tseason))
	then
		String _RULENAME = drools.getRule().getName();
		TargetSeriesSelection tss = new TargetSeriesSelection($tseries, schedule);
		insert(tss);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection added to fact list: " + tss.toString());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Initialize Next Non-Seasonal TargetSeriesSelection" ruleflow-group "SeriesSelection"
	dialect "mvel"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionSeason == null)
		// Perform selection on series; higher priority vaccine groups first and those with seasons in start date ascending order
		not TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionVaccineGroup != $tss.seriesSelectionVaccineGroup, seriesSelectionPriority > $tss.seriesSelectionPriority, seriesGroup < $tss.seriesGroup)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($tss) {
			setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection Initialized " + $tss.toString() + ", Vaccine Group Priority " + $tss.seriesSelectionPriority);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Initialize Next Seasonal TargetSeriesSelection" ruleflow-group "SeriesSelection"
	dialect "mvel"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionSeason != null)
		// Perform selection on series; higher priority vaccine groups first and those with seasons in start date ascending order
		not TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionVaccineGroup != $tss.seriesSelectionVaccineGroup, seriesSelectionPriority > $tss.seriesSelectionPriority, seriesGroup < $tss.seriesGroup) 
		not TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_NOT_STARTED, seriesSelectionVaccineGroup == $tss.seriesSelectionVaccineGroup, 
			seriesSelectionSeason != null && seriesSelectionSeason.fullySpecifiedSeasonStartDate.isBefore($tss.seriesSelectionSeason.fullySpecifiedSeasonStartDate))
	then
		modify ($tss) { 
			setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS);
		}
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection Initialized " + $tss.toString() + ", Vaccine Group Priority " + $tss.seriesSelectionPriority);
		setFocus("SeriesSelection^SeasonalSeriesPatientAgeOfInterest");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: Default Series Selection Preprocess rule: invoke custom rules" ruleflow-group "SeriesSelection"
	dialect "mvel"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS) 
	then
		String _RULENAME = kcontext.rule.name;
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoking Series Selection rules for vaccine group: " + $tss.seriesSelectionVaccineGroup);
		update($tss);
		setFocus("SeriesSelection^customSeriesSelectionRules");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: For the Seasonal Series being evaluated for SeriesSelection that is not in the current season, set patient age time of interest to last date of season if no shots administered and invoke custom rules"
	dialect "mvel"
	agenda-group "SeriesSelection^SeasonalSeriesPatientAgeOfInterest"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS, seriesSelectionSeason != null)
		not TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == true, targetSeason == $tss.seriesSelectionSeason)
		$ts : TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == false,	targetSeason == $tss.seriesSelectionSeason, numberOfShotsAdministeredInSeries == 0)
		exists TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", $ts.targetSeason.fullySpecifiedSeasonEndDate.toDate());
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: patientAgeTimeOfInterest set to season end date: " + $ts.targetSeason.fullySpecifiedSeasonEndDate.toDate());
		update($tss);
		setFocus("SeriesSelection^customSeriesSelectionRules");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: For the Seasonal Series being evaluated for SeriesSelection that is not in the current season, set patient age time of interest to last shot of the series and invoke custom rules"
	dialect "mvel"
	agenda-group "SeriesSelection^SeasonalSeriesPatientAgeOfInterest"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS, seriesSelectionSeason != null)
		not TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == true, targetSeason == $tss.seriesSelectionSeason)
		$ts : TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == false,	targetSeason == $tss.seriesSelectionSeason, numberOfShotsAdministeredInSeries > 0)
		exists TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;	
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", $ts.lastShotAdministeredInSeries.administrationDate);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: patientAgeTimeOfInterest set to last shot date in series: " + $ts.lastShotAdministeredInSeries.administrationDate);
		update($tss);
		setFocus("SeriesSelection^customSeriesSelectionRules");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "SeriesSelection: For the Seasonal Series being evaluated for SeriesSelection that is in the current season, set patient age time of interest to the execution time and invoke custom rules"
	dialect "mvel"
	agenda-group "SeriesSelection^SeasonalSeriesPatientAgeOfInterest"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PREPROCESS, seriesSelectionSeason != null)
		not TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == true, targetSeason == $tss.seriesSelectionSeason)
		$ts : TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == false, targetSeason == $tss.seriesSelectionSeason)
		not TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;
		kcontext.getKnowledgeRuntime().setGlobal("patientAgeTimeOfInterest", evalTime);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: patientAgeTimeOfInterest set to execution time: " + evalTime);
		update($tss);
		setFocus("SeriesSelection^customSeriesSelectionRules");
end


///////////////////////////////////////////////////////////// Series Selection Catch-All Rules Start Here /////////////////////////////////////////////////////////////

///////// ***
// General Design rule... Do not Edit 
// Updates series selection status for vaccine group to complete once series has been selected. 
///////// ***
rule "SeriesSelection: Change Series Selection Status To Complete" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 40
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS, $sss : seriesSelectionSeason)
		TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == true, targetSeason == $sss)
		not (TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == false, targetSeason == $sss))
	then
		String _RULENAME = kcontext.rule.name;
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_COMPLETE);
		update($tss);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeriesSelection: " + $tss.toString() + "; *Series* *Selected* " + $tss.getSelectedSeriesName());
end


///////// ***
// General Design rule... Do not Edit 
// Retracts all TargetSeries and corresponding TargetDoses in a vaccine group that remain (i.e. - were not chosen). 
// For Seasonal Series, since recommendations are only made on the current season
///////// ***
rule "SeriesSelection: Retract All Series Not Selected in the same Series Group and Vaccine Group" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 50
	when
		$tss : TargetSeriesSelection($ssvg : seriesSelectionVaccineGroup, $sss : seriesSelectionSeason, 
			seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS ||	seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_COMPLETE)
		$selected : TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == true, targetSeason == $sss)
		$ts : TargetSeries(seriesRules.vaccineGroup == $ssvg, selectedSeries == false, targetSeason == $sss, seriesRules.seriesGroup == $tss.seriesGroup)
	then
		String _RULENAME = kcontext.rule.name;
		for (TargetDose d : $ts.targetDoses) {
			ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetDose Retracted: " + d);
			retract(d);
		}
		retract($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries Retracted: " + $ts);
end


// AI: Move this to RecommendationForecast
///////// ***
// Supplemental Series Selection rule... Output Series Selection Information, if _OUTPUT_NUMBER_OF_DOSES_REMAINING option enabled
///////// ***
rule "SeriesSelection: Make a Record of all Non-Seasonal TargetSeries of the Vaccine Group for Series Selection Display purposes, if the Series Selection Display Option is Enabled" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 55
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_COMPLETE)
		exists TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == true)
		$ts : TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason == null)
		not SeriesDisplaySelection(targetSeries == $ts)
	then
		String _RULENAME = kcontext.rule.name;
		SeriesDisplaySelection ss = new SeriesDisplaySelection($ts);
		insert(ss);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Selection \": " + $ts.seriesName);	
end


// AI: Move this to RecommendationForecast
///////// ***
// Supplemental Series Selection rule... Output Series Selection Information, if _OUTPUT_NUMBER_OF_DOSES_REMAINING option enabled
///////// ***
rule "SeriesSelection: Maka a Record of Seasonal TargetSeries in the Current Season of the Vaccine Group for Series Selection Display purposes, if the Series Selection Display Option is Enabled" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 55
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_COMPLETE)
		exists TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == true)
		$ts : TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason != null, isSeriesComplete() == false)
		not SeriesDisplaySelection(targetSeries == $ts)
		not TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
	then
		String _RULENAME = kcontext.rule.name;
		SeriesDisplaySelection ss = new SeriesDisplaySelection($ts);
		insert(ss);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Selection \": " + $ts.seriesName);	
end



///////// ***
// Supplemental Series Selection rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// For all vaccine groups, if a series has not been selected by one of the custom rules and there are one or more series that have been completed, 
// select the series with the fewest doses necessary required to complete the series. 
///////// ***
rule "SeriesSelection: Select already completed series that has the fewest doses defined if exists and no series was previously selected" ruleflow-group "SeriesSelection"
	dialect "mvel"
	activation-group "SeriesSelectionFewestDoses"
	salience 60
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS)
		not (TargetSeries(selectedSeries == true, seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeason == $tss.seriesSelectionSeason))
		$ts1 : TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, isSeriesComplete() == true, $numberOfDosesInSeries1 : seriesRules.numberOfDosesInSeries, targetSeason == $tss.seriesSelectionSeason)
		not (TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, isSeriesComplete() == true, $numberOfDosesInSeries1 > seriesRules.numberOfDosesInSeries, targetSeason == $tss.seriesSelectionSeason, seriesRules.seriesGroup == $tss.seriesGroup))
	then
		String _RULENAME = kcontext.rule.name;
		$ts1.setSelectedSeries(true);
		$tss.setSelectedSeriesName($ts1.seriesName);
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_COMPLETE);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: TargetSeries " + $ts1);
		update($ts1);
		update($tss);	
end


///////// ***
// Supplemental Series Selection rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If more than one series is complete but one of them has already been selected which completed after one of the other series, change the series
// selected to the one that was completed the soonest.
///////// ***
rule "SeriesSelection: Select already _completed_ series with earliest completion date if exists and a different, _completed_ series was previously selected" ruleflow-group "SeriesSelection"
	dialect "java"
	salience 60
	activation-group "SeriesSelectionFewestDoses"
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS)
		$ts1 : TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, $id1 : targetSeriesIdentifier, selectedSeries == true, targetSeason == $tss.seriesSelectionSeason, $seriesComplete1 : isSeriesComplete(), 
			$seriesGroup1 : seriesRules.SeriesGroup, $lastNecessaryShotAdministered1 : getValidShotByDoseNumber(seriesRules.numberOfDosesInSeries))
		$ts2 : TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, targetSeriesIdentifier != $ts1.targetSeriesIdentifier, selectedSeries == false, targetSeason == $tss.seriesSelectionSeason, $seriesComplete2 : isSeriesComplete(), 
			$seriesGroup2 : seriesRules.seriesGroup, $lastAdministeredShot2InSeries: lastShotAdministeredInSeries, $lastNecessaryShotAdministered2 : getValidShotByDoseNumber(seriesRules.numberOfDosesInSeries))
		eval($seriesComplete1 == true && $seriesComplete2 == true && $seriesGroup1 == $seriesGroup2 && ($lastAdministeredShot2InSeries == null || 
			($lastNecessaryShotAdministered1 != null && $lastNecessaryShotAdministered2 != null && $lastNecessaryShotAdministered2.getAdministrationDate() != null && 
				$lastNecessaryShotAdministered2.getAdministrationDate().before($lastNecessaryShotAdministered1.getAdministrationDate()))))
	then
		String _RULENAME = drools.getRule().getName();
		$ts1.setSelectedSeries(false);
		$ts2.setSelectedSeries(true);
		$tss.setSelectedSeriesName($ts2.getSeriesName());
		$tss.setSeriesSelectionStatus(SeriesSelectionStatus.SERIES_SELECTION_COMPLETE);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Previously Selected TargetSeries Retracted for Already Complete Series: " + $ts2);
		update($ts1);
		update($ts2);
end


// Select only available series if there is only one in the vaccine group
rule "SeriesSelection.SelectOnlySeriesRemainingInVaccineGroup" ruleflow-group "SeriesSelection"
	dialect "mvel"
	salience 100
	when
		$tss : TargetSeriesSelection(seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_PROCESS || seriesSelectionStatus == SeriesSelectionStatus.SERIES_SELECTION_IN_POSTPROCESS)
		not TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == true)
		$ts : TargetSeries(seriesRules.vaccineGroup == $tss.seriesSelectionVaccineGroup, selectedSeries == false)
		accumulate($tsthis : TargetSeries(vaccineGroup == $tss.seriesSelectionVaccineGroup); $countInVG : count($tsthis); $countInVG == 1)		
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "SeriesSelection: TargetSeries " + $ts);
		$ts.setSelectedSeries(true);
		$tss.setSelectedSeriesName($ts.seriesName);
		update($ts);	
end


/*****************************************************************************************************************************************************************************/
// 											Ruleflow group for forecasting "RecommendationForecast"
/*****************************************************************************************************************************************************************************/


///////// ***	
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.findMostRecentAdministeredLiveVirusVaccineDate" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 10
	when
		$lvd : LiveVirusFact(LiveVirusDateSet == false)
		exists (TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED))
		exists (TargetDose(vaccineComponent.isLiveVirusVaccine == true))
		$maxdate : Date() from accumulate(TargetDose(vaccineComponent.isLiveVirusVaccine == true, $date : administrationDate), maxDate($date))
	then
		String _RULENAME = kcontext.rule.name;
		modify($lvd) {
			setLiveVirusDate($maxdate),		
			setLiveVirusDateSet(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Found most recent live virus vaccine administered on " + $lvd.getLiveVirusDate());
end


///////// ***	
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.findMostRecentAdministeredSelectAdjuvantProductVaccineDate" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 10
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDateSet == false)
		exists (TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED))
		exists (TargetDose(vaccineComponent.isSelectAdjuvantProduct == true))
		$maxdate : Date() from accumulate(TargetDose(vaccineComponent.isSelectAdjuvantProduct == true, $date : administrationDate), maxDate($date))
	then
		String _RULENAME = kcontext.rule.name;
		modify($dft) {
			setFactDate($maxdate);
		}		
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Found most recent adjuvant product vaccine administered on " + $dft.getFactDate());
end



/*
///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.setNextSeasonalTargetSeriesForRecommendation" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		// To avoid activation-group clashes, only forecast one series at a time
		not TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS || recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)
		$ts: TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED, $vg : vaccineGroup, isSelectedSeries() == true, targetSeason != null, 
			$tseasonStartDate : targetSeason.fullySpecifiedSeasonStartDate)
		not TargetSeries(vaccineGroup == $vg, targetSeason != null,	targetSeason.fullySpecifiedSeasonStartDate.isAfter($tseasonStartDate)) 
	then
		String _RULENAME = kcontext.rule.name;		
		modify($ts) {
			setRecommendationStatus(RecommendationStatus.FORECASTING_IN_PROGRESS);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Forecasting TargetSeries " + $ts);
		setFocus("RecommendationForecast^preRecommendationValidation");
end
*/


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.setNextSeasonalTargetSeriesForRecommendation" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		// To avoid activation-group clashes, only forecast one series at a time
		not TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS || recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)
		$ts: TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED, isSelectedSeries() == true, targetSeason != null)
		not TargetSeries(vaccineGroup == $ts.vaccineGroup, targetSeason != null, targetSeason.fullySpecifiedSeasonStartDate.isAfter($ts.targetSeason.fullySpecifiedSeasonStartDate))
		(		
			TargetSeries(this == $ts, seriesRules.seriesGroup <= 0 || seriesRules.seriesGroup > 0 && seriesRules.seriesEndAge == null) 
			or
			/////// (
				/////// not TargetSeries(this != $ts, vaccineGroup == $ts.vaccineGroup, seriesStartAgeDate != null)
				/////// or
				// targetSeason == null because we don't want to compare defined ages with other seasonal series; we already selected the most recent/current series in the predicates above
				// However, all non-seasonal series, iof any, should come after this seasonal series
				//forall ($tssa : TargetSeries(this != $ts, vaccineGroup == $ts.vaccineGroup, seriesStartAgeDate != null, targetSeason == null, seriesRules.seriesGroup == $ts.seriesRules.seriesGroup)
				//	TargetSeries(this == $ts, seriesEndAgeDate == null || seriesEndAgeDate < $tssa.seriesStartAgeDate)
				//)
        	/////// )
        	not TargetSeries(this != $ts, vaccineGroup == $ts.vaccineGroup, targetSeason == null, $ts.seriesEndAgeDate != null, seriesStartAgeDate != null && seriesStartAgeDate > $ts.seriesEndAgeDate, seriesRules.seriesGroup == $ts.seriesRules.seriesGroup, 
        		numberOfShotsAdministeredInSeries > 0)
        )
	then
		String _RULENAME = kcontext.rule.name;	
		modify($ts) {
			setRecommendationStatus(RecommendationStatus.FORECASTING_IN_PROGRESS);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Forecasting TargetSeries " + $ts);
		setFocus("RecommendationForecast^preRecommendationValidation");
end


/*
///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.setNextNonSeasonalTargetSeriesForRecommendation" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		// To avoid activation-group clashes, only forecast one series at a time
		not TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS || recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)
		$ts: TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED, isSelectedSeries() == true, targetSeason == null)
	then
		String _RULENAME = kcontext.rule.name;		
		RecommendationStatus newRecommendationStatus = RecommendationStatus.FORECASTING_IN_PROGRESS;
		modify($ts) {
			setRecommendationStatus(newRecommendationStatus);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Forecasting TargetSeries " + $ts);
		setFocus("RecommendationForecast^preRecommendationValidation");
end
*/

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.setNextNonSeasonalTargetSeriesForRecommendation" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		// To avoid activation-group clashes, only forecast one series at a time
		not TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS || recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)
		$ts: TargetSeries(recommendationStatus == RecommendationStatus.NOT_FORECASTED, isSelectedSeries() == true, targetSeason == null)
		(		
			TargetSeries(this == $ts, seriesRules.seriesGroup <= 0 || seriesRules.seriesGroup > 0 && seriesRules.seriesEndAge == null) 
			or
			/////// (
			///////	not TargetSeries(this != $ts, vaccineGroup == $ts.vaccineGroup, seriesRules.seriesGroup == $ts.seriesRules.seriesGroup, seriesRules.seriesStartAge != null)
			///////	or
			///////	forall ($tssa : TargetSeries(this != $ts, vaccineGroup == $ts.vaccineGroup, seriesRules.seriesGroup == $ts.seriesRules.seriesGroup)
			///////		TargetSeries(this == $ts, seriesStartAgeDate == null || seriesEndAgeDate == null || seriesStartAgeDate > $tssa.seriesEndAgeDate)
			///////	)
        	/////// )
        	not TargetSeries(this != $ts, vaccineGroup == $ts.vaccineGroup, $ts.seriesEndAgeDate != null, seriesStartAgeDate != null && seriesStartAgeDate > $ts.seriesEndAgeDate, seriesRules.seriesGroup == $ts.seriesRules.seriesGroup, 
        		numberOfShotsAdministeredInSeries > 0)
        )
	then
		String _RULENAME = kcontext.rule.name;		
		RecommendationStatus newRecommendationStatus = RecommendationStatus.FORECASTING_IN_PROGRESS;
		modify($ts) {
			setRecommendationStatus(newRecommendationStatus);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Forecasting TargetSeries " + $ts);
		setFocus("RecommendationForecast^preRecommendationValidation");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.applyPostRecommendationCheck" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 20
	no-loop true
	when
		$targetSeries : TargetSeries(isPostForecastCheckCompleted() == false && 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE ||
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED || recommendationStatus == RecommendationStatus.NOT_RECOMMENDED))
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Post recommendation check for TargetSeries " + $targetSeries.getSeriesName());
		/////// modify($targetSeries) {
		///////	setPostForecastCheckCompleted(false);
		/////// }
		update($targetSeries);
		setFocus("RecommendationForecast^postRecommendationCheck");
		setFocus("RecommendationForecast^postCustomRecommendationCheck");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.noteCompletionOfPostRecommendationCheck - Do _not_ reprocess recommendation rules" ruleflow-group "RecommendationForecast"
dialect "mvel"
	salience 10
	when
		$targetSeries : TargetSeries(isPostForecastCheckCompleted() == false, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE ||
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED || recommendationStatus == RecommendationStatus.NOT_RECOMMENDED))
then
	String _RULENAME = kcontext.rule.name;
	modify($targetSeries) {
		setRecommendationStatus(RecommendationStatus.FORECASTING_COMPLETE),
		setPostForecastCheckCompleted(true);
	}
	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Note Completion of Post recommendation check for TargetSeries " + $targetSeries.getSeriesName());
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.noteCompletionOfPostRecommendationCheck - _Do_ reprocess recommendation rules"
	dialect "mvel"
	agenda-group "RecommendationForecast^postRecommendationCheck"
	when
		$targetSeries : TargetSeries(isPostForecastCheckCompleted() == false, recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		modify($targetSeries) {
			clearRecommendations(),
			setPostForecastCheckCompleted(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Note Completion of Post recommendation check for TargetSeries " + $targetSeries.getSeriesName());
		setFocus("RecommendationForecast^preRecommendationValidation");
end


/*************************************************************************************************************************************************************************************
 START Rules for adjusting live virus intervals to ensure adequate spacing between live virus vaccines
/************************************************************************************************************************************************************************************/

///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a live virus vaccine and other live virus shots have been administered less than 28 days from 
// the recommendation date, then adjust the earliest recommendation date to be 28 days later than the most recent live virus shot
///////// ***
rule "RecommendationForecast.adjustEarliestDateDueToLiveVirusToFutureDate"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$lvd : LiveVirusFact(liveVirusDate != null, liveVirusDateSet == true)				  
		$targetSeries : TargetSeries($earliestDate : getFinalEarliestDate() != null,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedLiveVirusVaccine() == true,
				liveVirusDatesAccountedForInRecommendedFinalEarliestDate not contains $lvd.liveVirusDate)
		eval((TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS)))))
	then
		String _RULENAME = kcontext.rule.name;
		Date $newRecommendationDate = TimePeriod.addTimePeriod($lvd.liveVirusDate, new TimePeriod(28, DurationType.DAYS));
		modify($targetSeries) {
			setFinalEarliestDate($newRecommendationDate),
			addLiveVirusDateAccountedForInRecommendedFinalEarliestDate($lvd.liveVirusDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Earliest date adjustment from " + $earliestDate + " to " + $newRecommendationDate + " due to live virus vaccine administered on : " + $lvd.liveVirusDate + " in TargetSeries " + $targetSeries.getSeriesName());
end 


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a live virus vaccine, other live virus shots have been administered more than 28 days in the past,
// and the live virus date is the same as today's date, set the earliest date for the shot previously recommended in the past to today's date
///////// ***
rule "RecommendationForecast.adjustPriorEarliestDateDueToLiveVirusToCurrentDate"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$lvd : LiveVirusFact(liveVirusDate != null, liveVirusDateSet == true)				  
		$targetSeries : TargetSeries($earliestDate : getFinalEarliestDate() != null, $earliestDate < $lvd.liveVirusDate,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedLiveVirusVaccine() == true,
				liveVirusDatesAccountedForInRecommendedFinalEarliestDate not contains $lvd.liveVirusDate)
		eval(TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) == 0 &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS)))
	then
		String _RULENAME = kcontext.rule.name;
		modify($targetSeries) {
			setFinalEarliestDate($lvd.liveVirusDate),
			addLiveVirusDateAccountedForInRecommendedFinalEarliestDate($lvd.liveVirusDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Earliest date adjustment from " + $earliestDate + " to " + $lvd.liveVirusDate + " due to live virus vaccine administered on : " + $lvd.liveVirusDate + " in TargetSeries " + $targetSeries.getSeriesName());
end 


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a live virus vaccine and other live virus shots have been administered less than 28 days from 
// the recommendation date, then adjust the recommendation date to be 28 days later than the most recent live virus shot
///////// ***
rule "RecommendationForecast.adjustRecommendedDateDueToLiveVirusToFutureDate"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$lvd : LiveVirusFact(liveVirusDate != null, liveVirusDateSet == true)
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedLiveVirusVaccine() == true,
				liveVirusDatesAccountedForInRecommendedFinalDate not contains $lvd.liveVirusDate)
		eval((TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS)))))
	then
		String _RULENAME = drools.getRule().getName();
		Date newRecommendationDate = TimePeriod.addTimePeriod($lvd.liveVirusDate, new TimePeriod(28, DurationType.DAYS));
		modify($targetSeries) {
			setFinalRecommendationDate(newRecommendationDate),
			addLiveVirusDateAccountedForInRecommendedFinalDate($lvd.liveVirusDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "evalTime " + evalTime + "; Recommendation date adjustment from " + $recommendationDueDate + " to " + newRecommendationDate + " due to live virus vaccine administered on : " + $lvd.liveVirusDate + " in TargetSeries " + $targetSeries.getSeriesName());			
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a live virus vaccine, other live virus shots have been administered more than 28 days in the past,
// and the live virus date is the same as today's date, set the recommended date for the shot previously recommended in the past to today's date
///////// ***
rule "RecommendationForecast.adjustRecommendedDateDueToLiveVirusToCurrentDate"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$lvd : LiveVirusFact(liveVirusDate != null, liveVirusDateSet == true)
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null, $recommendationDueDate < $lvd.liveVirusDate,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedLiveVirusVaccine() == true,
				liveVirusDatesAccountedForInRecommendedFinalDate not contains $lvd.liveVirusDate)
		eval(TimePeriod.differenceInDays($lvd.liveVirusDate, evalTime) == 0 &&
			TimePeriod.calculateElapsedTimePeriod($lvd.liveVirusDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS)))
	then
		String _RULENAME = drools.getRule().getName();
		modify($targetSeries) {
			setFinalRecommendationDate($lvd.liveVirusDate),
			addLiveVirusDateAccountedForInRecommendedFinalDate($lvd.liveVirusDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "evalTime " + evalTime + "; Recommendation date adjustment from " + $recommendationDueDate + " to " + $lvd.liveVirusDate + " due to live virus vaccine administered on : " + $lvd.liveVirusDate + " in TargetSeries " + $targetSeries.getSeriesName());			
end

/*************************************************************************************************************************************************************************************
 END Rules for adjusting live virus intervals to ensure adequate spacing between live virus vaccines
/************************************************************************************************************************************************************************************/


/*************************************************************************************************************************************************************************************
 START Rules for adjusting adjuvant product intervals to ensure adequate spacing between vaccines with adjuvant
/************************************************************************************************************************************************************************************/

///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a select adjuvant product and other select adjuvant product shots been administered less than 28 days
// from the recommendation date, then adjust the earliest recommendation date to be 28 days later than the most recent select adjuvant product
///////// ***
rule "RecommendationForecast.adjustEarliestDateDueToSelectAdjuvantProductToFutureDate"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDate != null, factDateSet == true, $dftDate : factDate)
		$targetSeries : TargetSeries($earliestDate : getFinalEarliestDate() != null, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedSelectAdjuvantProduct() == true)  
		eval((TimePeriod.differenceInDays($dftDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($dftDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS)))))
	then
		String _RULENAME = kcontext.rule.name;
		Date $newRecommendationDate = TimePeriod.addTimePeriod($dftDate, new TimePeriod(28, DurationType.DAYS));
		modify($targetSeries) {
			setFinalEarliestDate($newRecommendationDate),
			addAdjuvantDateAccountedForInRecommendedFinalDate($dftDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Earliest date adjustment from " + $earliestDate + " to " + $newRecommendationDate + " due to select adjuvant product administered on : " + $dftDate + " in TargetSeries " + $targetSeries.getSeriesName());			
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a select adjuvant product, other adjuvant shots have been administered more than 28 days in the past,
// and the adjuvant date is the same as today's date, set the earliest date for the shot previously recommended in the past to today's date
///////// ***
rule "RecommendationForecast.adjustEarliestDateDueToSelectAdjuvantProductToCurrentDate"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDate != null, factDateSet == true, $dftDate : factDate)
		$targetSeries : TargetSeries($earliestDate : getFinalEarliestDate() != null, $earliestDate < $dftDate,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedSelectAdjuvantProduct() == true)  
		eval(TimePeriod.differenceInDays($dftDate, evalTime) == 0 &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $earliestDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS)))
	then
		String _RULENAME = kcontext.rule.name;
		modify($targetSeries) {
			setFinalEarliestDate($dftDate),
			addAdjuvantDateAccountedForInRecommendedFinalDate($dftDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Earliest date adjustment from " + $earliestDate + " to " + $dftDate + " due to select adjuvant product administered on : " + $dftDate + " in TargetSeries " + $targetSeries.getSeriesName());			
end


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a select adjuvant product and other select adjuvant product shots have been administered less than 28 days
// from the recommendation date, then adjust the recommendation date to be 28 days later than the most recent select adjuvant product
///////// ***
rule "RecommendationForecast.adjustRecommendedDateDueToSelectAdjuvantProductToFutureDate"
	dialect "java"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDate != null, factDateSet == true, $dftDate : factDate)
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedSelectAdjuvantProduct() == true)  
		eval((TimePeriod.differenceInDays($dftDate, evalTime) != 0 &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS))) ||
			(TimePeriod.differenceInDays($dftDate, evalTime) == 0 &&
			(TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(28, DurationType.DAYS)) &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isGreaterThan(new TimePeriod(0, DurationType.DAYS))))) 
	then
		String _RULENAME = drools.getRule().getName();
		Date $newRecommendationDate = TimePeriod.addTimePeriod($dftDate, new TimePeriod(28, DurationType.DAYS));
		modify($targetSeries) {
			setFinalRecommendationDate($newRecommendationDate),
			addAdjuvantDateAccountedForInRecommendedFinalDate($dftDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Recommendation date adjustment from " + $recommendationDueDate + " to " + $newRecommendationDate + " due to select adjuvant product administered on : " + $dftDate + " in TargetSeries " + $targetSeries.getSeriesName());			
end 


///////// ***
// Supplemental Recommendation rule... modifying this rule not suggested; support for modifying this rule will be available in a future release
// If a recommended, conditionally recommended, or future recommendation for a select adjuvant product, other adjuvant shots have been administered more than 28 days in the past,
// and the adjuvant date is the same as today's date, set the earliest date for the shot previously recommended in the past to today's date
///////// ***
rule "RecommendationForecast.adjustRecommendedDateDueToSelectAdjuvantProductToCurrentDate"
	dialect "java"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$dft : DateFactType(factName == "SELECT_ADJUVANT_PRODUCT_INTERVAL", factDate != null, factDateSet == true, $dftDate : factDate)
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null, $recommendationDueDate < $dftDate,
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED), isRecommendedVaccineOrVaccineGroupLevelRecommendationAnExpectedSelectAdjuvantProduct() == true)  
		eval(TimePeriod.differenceInDays($dftDate, evalTime) == 0 &&
			TimePeriod.calculateElapsedTimePeriod($dftDate, $recommendationDueDate, DurationType.DAYS, false).isLessThan(new TimePeriod(-28, DurationType.DAYS)))
	then
		String _RULENAME = drools.getRule().getName();
		modify($targetSeries) {
			setFinalRecommendationDate($dftDate),
			addAdjuvantDateAccountedForInRecommendedFinalDate($dftDate),
			addSeriesRuleProcessed(_RULENAME);
		}
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Recommendation date adjustment from " + $recommendationDueDate + " to " + $dftDate + " due to select adjuvant product administered on : " + $dftDate + " in TargetSeries " + $targetSeries.getSeriesName());			
end 

/*************************************************************************************************************************************************************************************
 END Rules for adjusting adjuvant product intervals to ensure adequate spacing between vaccines with adjuvant
/************************************************************************************************************************************************************************************/


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.adjustTargetSeriesEnclosedRecommendationWithRespectToEvalTime"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	no-loop true
	when
		$targetSeries : TargetSeries($recommendationDueDate : finalRecommendationDate)
		List(size > 0) from	accumulate($recs : Recommendation((recommendationStatus == RecommendationStatus.NOT_FORECASTED && recommendationReason != null) || 
				(recommendationStatus == RecommendationStatus.RECOMMENDED && $recommendationDueDate > evalTime) || 
				(recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE && $recommendationDueDate <= evalTime)) from $targetSeries.finalRecommendations, collectList($recs))
	then
		String _RULENAME = kcontext.rule.name;
		// Update the recommendation status and reason; if they are not updated, then just update the recommendation status only of NOT_FORECASTED recommendation objects to target series' status
		if ($targetSeries.adjustRecommendationStatusAndReasonByEvalTime(evalTime) == false) {
			for (Recommendation r : $targetSeries.getFinalRecommendations()) {
				if (r.getRecommendationStatus() == RecommendationStatus.NOT_FORECASTED) {
					r.setRecommendationStatus($targetSeries.getRecommendationStatus);
				}
			}
		}
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Enclosed Recommendation statuses adjusted in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.adjustRecommendedStatusAndEnclosedRecommendationsWithRespectToEvalTime"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$targetSeries : TargetSeries($recommendationDueDate : getFinalRecommendationDate() != null, 
			(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED),
			$recommendationDueDate > evalTime && recommendationStatus == RecommendationStatus.RECOMMENDED || $recommendationDueDate <= evalTime && recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE)
	then
		String _RULENAME = kcontext.rule.name;
		$targetSeries.adjustRecommendationStatusAndReasonByEvalTime(evalTime);
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
      	ICELogicHelper.logDRLDebugMessage(_RULENAME, "Recommendation status and enclosed Recommendations adjusted for " + $recommendationDueDate + " in TargetSeries " + $targetSeries.getSeriesName());			
		update($targetSeries);	
end


///////// ***
// General Design rule... Do not Edit
// Per ICE SME group, if recommendation is conditional, do not display a recommendation date. This can be overrided via TargetSeries.setDisplayForecastDateForConditionalRecommendations()
///////// ***
rule "RecommendationForecast.doNotReturnForecastDateForConditionalRecommendations"
	dialect "java"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, isForecastDateDisplayedForConditionalRecommendations() == false, 
			finalRecommendationDate != null || finalEarliestDate != null || finalOverdueDate != null)
	then
		String _RULENAME = drools.getRule().getName();
		$ts.setFinalRecommendationDate(null);
		update($ts);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.getSeriesName());
end


///////// ***
// General Design rule... Do not Edit
// If the list of recommended vaccines are inconsistent (i.e. - different interim recommendation forecasts with different vaccines), and the patient is recommended 
// for a forecast, then log the inconsistency and recommend at the vaccine group level
///////// ***
rule "RecommendationForecast.recommendedAtVaccineGroupLevelIfRecommendedVaccinesNotConsistentWithRecommendationObjects"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE ||
				recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations)
		HashSet(size > 1) from accumulate(Recommendation(recommendedVaccine != null, $accRecommendedVaccine : recommendedVaccine) from $tsFinalRecommendations, collectSet($accRecommendedVaccine))
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationVaccine(null);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General Design rule... Do not Edit
// If the list of recommended vaccines are inconsistent (i.e. - different interim recommendation forecasts with different vaccines), and the patient is recommended 
// for a forecast, then log the inconsistency and recommend at the vaccine group level
///////// ***
rule "RecommendationForecast.recommendedAtVaccineGroupLevelIfRecommendedVaccinesNotConsistentWithTargetSeries"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations, recommendationVaccine != null, 
			$tsRecommendedVaccine: recommendationVaccine)
		HashSet(size > 0) from accumulate(Recommendation(recommendedVaccine != null, recommendedVaccine != $tsRecommendedVaccine, $accRecommendedVaccine : recommendedVaccine) 
			from $tsFinalRecommendations, collectSet($accRecommendedVaccine))
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationVaccine(null);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end

	
///////// ***
// General Design rule... Do not Edit
// If the list of recommended vaccines are consistent and not all empty, and the patient is recommended for a forecast, then recommend at the vaccine level of the only specified vaccine.
// Set each Recommendation Object's recommendedVaccine to null and set the TargetSeries recommendationVaccine to the 1 and only 1 vaccine
///////// ***
rule "RecommendationForecast.recommendedAtVaccineLevelIfRecommendedVaccinesConsistentWithRecommendationObjects"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || 
			recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations)
		$recommendationVaccineSet : Set(size == 1) from accumulate(Recommendation(recommendedVaccine != null, $accRecommendedVaccine : recommendedVaccine) from $tsFinalRecommendations, collectSet($accRecommendedVaccine))
		$tsSame : TargetSeries(targetSeriesIdentifier == $ts.targetSeriesIdentifier, recommendationVaccine == null || recommendationVaccine != null && recommendationVaccine memberOf $recommendationVaccineSet)
		$recommendationVaccineList : List() from accumulate($acc2Recommendation : Recommendation(recommendedVaccine != null) from $tsFinalRecommendations, collectList($acc2Recommendation))
	then
		String _RULENAME = kcontext.rule.name;
		Iterator iter = $recommendationVaccineSet.iterator();
		if (iter.hasNext()) {
			Vaccine v = (Vaccine) iter.next();
			$ts.setRecommendationVaccine(v);
		}
		Iterator iter2 = $recommendationVaccineList.iterator();
		while (iter2.hasNext()) {
			Recommendation r = (Recommendation) iter2.next();
			r.setRecommendedVaccine(null);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General Design rule... Do not Edit
// Recommend at vaccine group level if recommendation status (forecast) is NOT_RECOMMENDED
///////// ***
rule "RecommendationForecast.recommendedAtVaccineGroupLevelIfNotRecommendedForecast"
	dialect "mvel"
	agenda-group "RecommendationForecast^supplementalSeriesRule"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.NOT_RECOMMENDED, finalRecommendations != null, $tsFinalRecommendations : finalRecommendations)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.setRecommendationVaccine(null);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General rule
// Earliest, Recommended, and Past Due Dates must be on or after the Last Shot Given
///////// ***
rule "RecommendationForecast.recommendEarliestDateOnOrAfterLastShotGiven"
	dialect "mvel"
	agenda-group "RecommendationForecast^adjustRecommendationDates"
	when
		$ts : TargetSeries(finalEarliestDate != null)
		$td : TargetDose(associatedTargetSeries == $ts, administrationDate > $ts.finalEarliestDate)
		not TargetDose(associatedTargetSeries == $ts, administrationDate > $td.administrationDate)
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setFinalEarliestDate($td.administrationDate);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General rule
// Earliest, Recommended, and Past Due Dates must be on or after the Last Shot Given
///////// ***
rule "RecommendationForecast.recommendRecommendedDateOnOrAfterLastShotGiven"
	dialect "mvel"
	agenda-group "RecommendationForecast^adjustRecommendationDates"
	when
		$ts : TargetSeries(finalRecommendationDate != null)
		$td : TargetDose(associatedTargetSeries == $ts, administrationDate > $ts.finalRecommendationDate)
		not TargetDose(associatedTargetSeries == $ts, administrationDate > $td.administrationDate)
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setFinalRecommendationDate($td.administrationDate);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General rule
// Earliest, Recommended, and Past Due Dates must be on or after the Last Shot Given
///////// ***
rule "RecommendationForecast.recommendOverdueDateOnOrAfterLastShotGiven"
	dialect "mvel"
	agenda-group "RecommendationForecast^adjustRecommendationDates"
	when
		$ts : TargetSeries(finalOverdueDate != null)
		$td : TargetDose(associatedTargetSeries == $ts, administrationDate > $ts.finalOverdueDate)
		not TargetDose(associatedTargetSeries == $ts, administrationDate > $td.administrationDate)
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setFinalOverdueDate($td.administrationDate);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.finalizeRecommendationsForSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)	
		not Recommendation(targetSeriesIdentifier == $ts.targetSeriesIdentifier)	
	then
		String _RULENAME = kcontext.rule.name;
		$ts.finalizeRecommendationsForForecasting();
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Finalized recommendations for TargetSeries " + $ts.getSeriesName());
		update($ts);
		setFocus("RecommendationForecast^supplementalSeriesRule");
		setFocus("RecommendationForecast^adjustRecommendationDates");
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.addAnyRecommendationsOnFactListToSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_COMPLETE)
		$recommendation : Recommendation(targetSeriesIdentifier == $ts.targetSeriesIdentifier)	
	then
		String _RULENAME = kcontext.rule.name;
		$ts.addInterimRecommendationForConsideration($recommendation, evalTime);
		retract($recommendation);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Finalized recommendations for TargetSeries " + $ts.getSeriesName());
		update($ts);
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "RecommendationForecast.allRecommendationRulesProcessedForSeries" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 95
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		modify($ts) {
			setRecommendationStatus(RecommendationStatus.FORECASTING_COMPLETE);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
// To follow CDC guidelines, could change this to only fire if a recommended age is available; then calculate earliest possible recommended date above
// using minimal age, minimum interval, etc. This separates the catch up schedule from the short recommendation intervals used by NYC
///////// ***
rule "RecommendationForecast.recommendBasedOnEarliestAgeRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "earliestAgeCheck"
	when
		// To follow CDC guidelines, could change this to check that a recommended age is provided
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestAgeRule($person.demographics.birthTime, $evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series Table rule... Do not edit
// To follow CDC guidelines, could change this to only fire if a recommended age is not available
///////// ***
rule "RecommendationForecast.recommendBasedOnEarliestIntervalRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "earliestIntervalCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestIntervalRule($evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table rule... Do not Edit
// To follow CDC guidelines, could change this to only fire if a recommended age is available; then calculate earliest possible recommended date above
// using minimal age, minimum interval, etc. This separates the catch up schedule from the short recommendation intervals used by NYC
///////// ***
rule "RecommendationForecast.recommendBasedOnLatestRecommendedAgeRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "latestRecommendedAgeCheck"
	when
		// To follow CDC guidelines, could change this to check that a recommended age is provided
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnLatestRecommendedAgeRule($person.demographics.birthTime, $evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series Table rule... Do not edit
// To follow CDC guidelines, could change this to only fire if a recommended age is not available
///////// ***
rule "RecommendationForecast.recommendBasedOnLatestRecommendedIntervalRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "latestRecommendedIntervalCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnLatestRecommendedIntervalRule($evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series table rule... Do not Edit
// To follow CDC guidelines, could change this to only fire if a recommended age is available; then calculate earliest possible recommended date above
// using minimal age, minimum interval, etc. This separates the catch up schedule from the short recommendation intervals used by NYC
///////// ***
rule "RecommendationForecast.recommendBasedOnEarliestRecommendedAgeRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "recommendationAgeCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
		$person : EvaluatedPerson()
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestRecommendedAgeRule($person.demographics.birthTime, $evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end 


///////// ***
// Series Table rule... Do not Edit
///////// ***
rule "RecommendationForecast.recommendBasedOnRecommendedIntervalRule" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	activation-group "recommendationIntervalCheck"
	when
		$evalTime : EvalTime()
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS)
	then
		String _RULENAME = kcontext.rule.name;
		$ts.recommendNextShotBasedOnEarliestRecommendedIntervalRule($evalTime.getEvalTimeValue());
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


rule "RecommendationForecast.Do Not Apply Earliest Interval for Dose 1 if Prior Shot for Target Dose 1 was Invalid due to Below Minimum Age" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 101
	activation-group "earliestIntervalCheck"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS, isSeriesComplete() == false, determineDoseNumberInSeries() == 1,
			$lastShotAdministered : lastShotAdministeredInSeries, $lastShotAdministered != null, $lastShotAdministered.doseNumberInSeries == 1,	
			$lastShotAdministered.getAdministeredVaccine().isLiveVirusVaccine() == false, $lastShotAdministered.getAdministeredVaccine().isSelectAdjuvantProduct() == false) 
		exists ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._BELOW_MINIMUM_AGE.conceptCodeValue, associatedTargetDose == $lastShotAdministered)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


rule "RecommendationForecast.Do Not Apply Recommended Interval for Dose 1 if Prior Shot for Target Dose 1 was Invalid due to Below Minimum Age" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 101
	activation-group "recommendationIntervalCheck"
	when
		$ts : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS, isSeriesComplete() == false, determineDoseNumberInSeries() == 1,
			$lastShotAdministered : lastShotAdministeredInSeries, $lastShotAdministered != null, $lastShotAdministered.doseNumberInSeries == 1,
			$lastShotAdministered.getAdministeredVaccine().isLiveVirusVaccine() == false, $lastShotAdministered.getAdministeredVaccine().isSelectAdjuvantProduct() == false) 
		exists ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._BELOW_MINIMUM_AGE.conceptCodeValue, associatedTargetDose == $lastShotAdministered)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts.seriesName);
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// For seasonal series, recommend shot on the first date of the next season or at the time that the patient becomes of minimum age
// Overrides age check
///////// ***
rule "RecommendationForecast: Recommend Earliest Recommended Age Date in Next Series Season as Specified by Default Season Series Rule if no next Fully-Specified Season Defined and during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "recommendationAgeCheck"
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, seriesRules.recurringDosesOccurAfterSeriesComplete() == false, $vg : vaccineGroup, targetSeason.dateIsApplicableToOffSeason(evalTime),
			$offSeasonEndDate : targetSeason.fullySpecifiedSeasonOffSeasonEndDate)
		not Season(isDefaultSeason() == false, vaccineGroup == $vg, fullySpecifiedSeasonStartDate.toDate() == $offSeasonEndDate.plusDays(1).toDate())
		$defaultSeason : Season(isDefaultSeason() == true, vaccineGroup == $vg)
		$s : SeriesRules(vaccineGroup == $vg, $defaultSeason memberOf seasons, getSeriesDoseRuleByDoseNumber(1) != null,
			$recommendedAge : getSeriesDoseRuleByDoseNumber(1).getEarliestRecommendedAge() != null)
		$person : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($birthDate, $offSeasonEndDate.plusDays(1).toDate(), $recommendedAge) > 0)		
	then
		String _RULENAME = kcontext.rule.name;
		Date calcRecDate = TimePeriod.addTimePeriod($birthDate, $recommendedAge);
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate(calcRecDate);
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);			
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// Recommend earliest recommended age date in the next series for each series rules that have a recommended age and for which there is an associated fully-specified season
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend at Earliest Recommended Age Date in Next Series Season as Specified by TargetSeries if Fully-Specified Season Defined and if during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "recommendationAgeCheck"
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, seriesRules.recurringDosesOccurAfterSeriesComplete() == false, targetSeason.dateIsApplicableToOffSeason(evalTime), 
			$offSeasonEndDate : targetSeason.fullySpecifiedSeasonOffSeasonEndDate, $offSeasonEndDate != null)
		$fullySpecifiedNextseason : Season(isDefaultSeason() == false, vaccineGroup == $ts.vaccineGroup, fullySpecifiedSeasonStartDate.toDate() == $offSeasonEndDate.plusDays(1).toDate())
		$sr : SeriesRules(vaccineGroup == $ts.vaccineGroup, $fullySpecifiedNextseason memberOf seasons, getSeriesDoseRuleByDoseNumber(1) != null,
			$recommendedAge : getSeriesDoseRuleByDoseNumber(1).getEarliestRecommendedAge() != null)
		$person : EvaluatedPerson($birthDate : demographics.birthTime)
		eval(TimePeriod.compareElapsedTimePeriodToDateRange($birthDate, $offSeasonEndDate.plusDays(1).toDate(), $recommendedAge) > 0)		
	then
		String _RULENAME = kcontext.rule.name;
		Date calcRecDate = TimePeriod.addTimePeriod($birthDate, $recommendedAge);
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate(calcRecDate);
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);			
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// For seasonal series, patients should receive a shot on the first date of the next season if evaluation time is *after* the season ended in current series
// Overrides interval check.
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend Next Season Earliest Start Date if during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "earliestIntervalCheck"	
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, seriesRules.recurringDosesOccurAfterSeriesComplete() == false, targetSeason.dateIsApplicableToOffSeason(evalTime))
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setEarliestDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);	
end


///////// ***
// Series Table SEASONS rule... Do not Edit
// For seasonal series, patients should receive a shot on the first date of the next season if evaluation time is *after* the season ended in current series
// Overrides interval check.
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend Next Season Recommended Start Date if during the Off-Season of Current Seasonal Series" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 110
	activation-group "recommendationIntervalCheck"	
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, seriesRules.recurringDosesOccurAfterSeriesComplete() == false, targetSeason.dateIsApplicableToOffSeason(evalTime)) 
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);	
end


///////// ***
// Series Table rule... Do not Edit
// For seasonal series, if the series is complete, recommend that the patient receive a shot on the season start date of the next season
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast: Recommend Next Season Start Date if Current Seasonal Series is Complete" ruleflow-group "RecommendationForecast"
	dialect "mvel"
	salience 100
	when
		$ts : TargetSeries(recommendationStatus == recommendationStatus.FORECASTING_IN_PROGRESS, targetSeason != null, targetSeason.fullySpecifiedSeasonOffSeasonEndDate != null, seriesRules.recurringDosesOccurAfterSeriesComplete() == false, isSeriesComplete() == true)
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);
end


///////// ***
// Series Table rule... Do not Edit
// For seasonal series, if the final recommendation date falls between the off-season start and end dates, modify the recommendation date to the
// beginning of the next season 
///////// ***
// AI: Look up the start date of the next season, if defined. Otherwise, set to the date of the default season.
rule "RecommendationForecast/Post Recommendation Check: Recommend Next Season Start Date if Final Recommendation Date during Off-Season"
	dialect "mvel"
	agenda-group "RecommendationForecast^postRecommendationCheck"
	when
		$ts : TargetSeries(isPostForecastCheckCompleted() == false, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendationDate != null, $pcvRecommendationDate : finalRecommendationDate, 
			targetSeason != null, finalRecommendationDate != null, targetSeason.fullySpecifiedSeasonOffSeasonStartDate != null, targetSeason.fullySpecifiedSeasonOffSeasonEndDate != null, seriesRules.recurringDosesOccurAfterSeriesComplete() == false) 
		eval($ts.getFinalRecommendationDate().compareTo($ts.getTargetSeason().getFullySpecifiedSeasonEndDate().toDate()) > 0 && 
			$ts.getFinalRecommendationDate().compareTo($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().toDate()) <= 0)
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation recommendation = new Recommendation($ts);
		recommendation.setRecommendationDate($ts.getTargetSeason().getFullySpecifiedSeasonOffSeasonEndDate().plusDays(1).toDate());
		$ts.addInterimRecommendationForConsideration(recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);		
end


///////// ***
// Series Table rule... Do not Edit
// For seasonal series, if the final recommendation date falls after the season end-date and there is no off-season, mark the series NOT_RECOMMENDED and COMPLETE, as there will
// not be a next season (this is the one-and-only season as indicated by the fact that there is no off-season)
///////// ***
rule "RecommendationForecast/Post Recommendation Check: Recommend Not Recommended and Complete if Final Recommendation Date after End Date and there is no Off-Season"
	dialect "mvel"
	agenda-group "RecommendationForecast^postRecommendationCheck"
	activation-group "postSeasonalSeriesNotRecommendedHandling"
	when
		$ts : TargetSeries(isPostForecastCheckCompleted() == false, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE || recommendationStatus == RecommendationStatus.CONDITIONALLY_RECOMMENDED, finalRecommendationDate != null, $pcvRecommendationDate : finalRecommendationDate, 
			targetSeason != null, finalRecommendationDate != null, targetSeason.fullySpecifiedSeasonOffSeasonEndDate == null) 
		eval($ts.getFinalRecommendationDate().compareTo($ts.getTargetSeason().getFullySpecifiedSeasonEndDate().toDate()) > 0)
	then
		String _RULENAME = kcontext.rule.name;
		Recommendation $recommendation = new Recommendation($ts); 
		$recommendation.setRecommendationStatus(RecommendationStatus.NOT_RECOMMENDED);
		$recommendation.setRecommendationReason(BaseDataRecommendationReason._NOT_RECOMMENDED_COMPLETE_REASON.getCdsListItemName());
		$ts.setSeriesComplete(true);
		$ts.addInterimRecommendationForConsideration($recommendation, evalTime);
		$ts.addSeriesRuleProcessed(_RULENAME);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "TargetSeries " + $ts);		
end


///////// ***
// Supplemental Recommendation rule... Do not Edit; support for modifying this rule will be available in a future release
// If the patient is immune (for any reason) to all of the diseases handled by the TargetSeries, mark the series and forecasting complete
///////// ***
rule "RecommendNotRecommendedIfImmuneToAllDiseasesInSeries"
	dialect "java"
	agenda-group "RecommendationForecast^preRecommendationValidation"
	when
		$targetSeries : TargetSeries(recommendationStatus == RecommendationStatus.FORECASTING_IN_PROGRESS, $diseasesSupportedByThisSeries : diseasesSupportedByThisSeries)
		do[invokeCustomRecommendationRules]
		Set(size == $diseasesSupportedByThisSeries.size()) from accumulate($di : DiseaseImmunity(dateOfImmunity <= evalTime, disease memberOf $diseasesSupportedByThisSeries), collectSet($di.getDisease()))
		$diseaseImmunityList : List() from accumulate($di : DiseaseImmunity(dateOfImmunity <= evalTime, disease memberOf $diseasesSupportedByThisSeries), collectList($di))
	then
		String _RULENAME = drools.getRule().getName();
		Recommendation $recommendation = new Recommendation($targetSeries); 
		$recommendation.setRecommendationStatus(RecommendationStatus.NOT_RECOMMENDED);
		Iterator dilIter = $diseaseImmunityList.iterator();
		while (dilIter.hasNext()) {	// Just take the first available immunity reason
			DiseaseImmunity diConsequence = (DiseaseImmunity) dilIter.next();
			String src = diConsequence.getRecommendationReasonResult();
			if (src != null) {
				$recommendation.setRecommendationReason(src);
				break;				
			}
		}
		$targetSeries.addInterimRecommendationForConsideration($recommendation, evalTime);
		$targetSeries.setSeriesComplete(true);
		modify ($targetSeries) {setRecommendationStatus(RecommendationStatus.FORECASTING_COMPLETE); }
		$targetSeries.addSeriesRuleProcessed(_RULENAME);
       	ICELogicHelper.logDRLDebugMessage(_RULENAME, "in TargetSeries " + $targetSeries.getSeriesName());
	then[invokeCustomRecommendationRules]
       	ICELogicHelper.logDRLDebugMessage(drools.getRule().getName(), "Check complete.");
       	drools.setFocus("RecommendationForecast^customRecommendationRule");
end


/*****************************************************************************************************************************************************************************/
// 													Ruleflow group for returning results
/*****************************************************************************************************************************************************************************/


///////// ***
// General Design rule... Do not Edit
///////// ***
function void setShotValidity(SubstanceAdministrationEvent sae, TargetDose td) {
	
	if (sae == null || td == null) {
		return;
	}
	
	BL currShotValidity = sae.getIsValid();
	if (currShotValidity == null || currShotValidity.isValue() == true) {
		BL shotValidity = new BL();
		shotValidity.setValue(td.getIsValid());
		sae.setIsValid(shotValidity);
	}

}


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Evaluations" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 10
	when
		$sae : SubstanceAdministrationEvent()	
		$td : TargetDose(doseId == $sae.id)
		$ts : TargetSeries(this == $td.associatedTargetSeries, $vaccineGroup : seriesRules.vaccineGroup, selectedSeries == true)
		not ICEFactTypeFinding(iceResultFinding == $sae.id, targetDose == $td)
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputNestedImmEvaluationResult(drools, namedObjects, $evalTime, focalPersonId, iceVersion, $sae, $vaccineGroup, $td, outputSupplementalText, true);
		$sae.setToBeReturned(true);
		ICEFactTypeFinding saeEvaluation = new ICEFactTypeFinding($sae.id, $td);
		insert(saeEvaluation);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing: " + $td);	
end


///////// ***
// Supplementary rule... To be migrated to custom rule
///////// ***
rule "ProcessResults(COVID-19): Return Sept 2023 Season Evaluations (always reset to dose 1 in the Sept 2023 season)" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 11
	when
		not ICEFactTypeFinding(iceResultFinding == "COVID19_SEP2023_DOSE_NUMBER_RESET_DISABLED")
		$sae : SubstanceAdministrationEvent()
		$td : TargetDose(doseId == $sae.id, associatedVaccineGroup == "VACCINE_GROUP_CONCEPT.850", associatedTargetSeries.targetSeasonExists() == true, administrationDate >= "12-Sep-2023")
		$ts : TargetSeries(this == $td.associatedTargetSeries, $vaccineGroup : seriesRules.vaccineGroup, selectedSeries == true, targetSeasonExists() == true, targetSeason.seasonName == "COVID19Sep2023Season")
		not ICEFactTypeFinding(iceResultFinding == $sae.id, targetDose == $td)
		$numberOfPreviousDoses: Integer() from accumulate($acctd: TargetDose(associatedVaccineGroup == "VACCINE_GROUP_CONCEPT.850", associatedTargetSeries == $ts, isValid == true, administrationDate >= "12-Sep-2023", administrationDate <= $td.administrationDate, 
			administeredShotNumberInSeries < $td.administeredShotNumberInSeries), count($acctd))
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		int doseNumberToDisplay = $numberOfPreviousDoses.intValue() == 0 ? 1 : $numberOfPreviousDoses.intValue()+1;
		p.OutputNestedImmEvaluationResult(drools, namedObjects, $evalTime, focalPersonId, iceVersion, $sae, $vaccineGroup, $td, outputSupplementalText, true, doseNumberToDisplay);
		$sae.setToBeReturned(true);
		ICEFactTypeFinding saeEvaluation = new ICEFactTypeFinding($sae.id, $td);
		insert(saeEvaluation);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing: " + $td);	
end


///////// ***
// Supplementary rule... To be migrated to custom rule
///////// ***
rule "ProcessResults(COVID-19): Return Sept 2023 Season Evaluations (CB2 - do not reset to 1 in the Sept 2023 season)" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 11
	when
		exists ICEFactTypeFinding(iceResultFinding == "COVID19_SEP2023_DOSE_NUMBER_RESET_DISABLED")
		$sae : SubstanceAdministrationEvent()
		$td : TargetDose(doseId == $sae.id, associatedVaccineGroup == "VACCINE_GROUP_CONCEPT.850", associatedTargetSeries.targetSeasonExists() == true)
		$ts : TargetSeries(this == $td.associatedTargetSeries, $vaccineGroup : seriesRules.vaccineGroup, selectedSeries == true, targetSeasonExists() == true, targetSeason.seasonName == "COVID19Sep2023Season")
		not ICEFactTypeFinding(iceResultFinding == $sae.id, targetDose == $td)
		$numberOfPreviousDoses: Integer() from accumulate($acctd: TargetDose(associatedVaccineGroup == "VACCINE_GROUP_CONCEPT.850", administrationDate < $td.administrationDate, isValid == true), count($acctd))
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputNestedImmEvaluationResult(drools, namedObjects, $evalTime, focalPersonId, iceVersion, $sae, $vaccineGroup, $td, outputSupplementalText, true, $numberOfPreviousDoses.intValue()+1);
		$sae.setToBeReturned(true);
		ICEFactTypeFinding saeEvaluation = new ICEFactTypeFinding($sae.id, $td);
		insert(saeEvaluation);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing: " + $td);	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Mark Unprocessed Shots as Vaccine Not Supported" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 10
	when
		exists ICEFactTypeFinding(iceResultFinding == "UNSUPPORTED_VACCINES_GROUP_FEATURE_ENABLED")
		ImmunizationConcept($ctid : conceptTargetId)
		$sae : SubstanceAdministrationEvent(id == $ctid)
		not TargetDose(doseId == $sae.id)
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputNestedImmEvaluationNotSupported(drools, namedObjects, $evalTime, focalPersonId, iceVersion, $sae, "VACCINE_GROUP_CONCEPT.999");
		$sae.setToBeReturned(true);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing: " + $sae);	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Recommendations for Vaccines Not Supported" extends "ProcessResults: Mark Unprocessed Shots as Vaccine Not Supported" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 10
	when
		not ObservationResult(observationValue != null && observationValue.concept != null && 
			observationValue.concept == PayloadHelper.getLocalCodeForRecommendationStatus(RecommendationStatus.RECOMMENDATION_NOT_AVAILABLE, schedule))
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.outputOtherImmRecommendationSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, iceVersion); 
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");		
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Check Non-Seasonal Series Selection Consistency" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 20
	when
		$s : SeriesRules($vg : vaccineGroup)
		exists TargetSeries(vaccineGroup == $vg, targetSeason == null)
		accumulate($tsthis : TargetSeries(vaccineGroup == $vg, isSelectedSeries() == true, targetSeason == null); $countInVG : count($tsthis); $countInVG != 1)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "No *non-seasonal* series properly selected for vaccine group " + $vg + "; count of series was: " + $countInVG);
		ICELogicHelper.throwRuntimeException(new InconsistentConfigurationException("No *non-seasonal* series properly selected for vaccine group " + $vg + ". Count of Series was: " + $countInVG));
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Check Seasonal SeriesSelection Consistency" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 20
	when
		$season: Season(isDefaultSeason() == false, $vg : vaccineGroup)
		exists TargetSeries(vaccineGroup == $vg, targetSeason != null, targetSeason == $season)
		accumulate($tsthis : TargetSeries(vaccineGroup == $vg, isSelectedSeries() == true, targetSeason == $season); $countInVG : count($tsthis); $countInVG != 1)			
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "No *seasonal* series properly selected for vaccine group " + $vg + "; count of series was: " + $countInVG);
		ICELogicHelper.throwRuntimeException(new InconsistentConfigurationException("No *seasonal* series properly selected for vaccine group " + $vg ". Count of Series was: " + $countInVG));
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Recommendation for Non-Seasonal Series" ruleflow-group "ProcessResults"
	dialect "mvel"
	lock-on-active true
	salience 10
	when
		$ts : TargetSeries(targetSeason == null)
		$evalTime: EvalTime()
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		SubstanceAdministrationProposal sap = p.OutputRootImmRecommendationSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, iceVersion, $ts, outputEarliestOverdueDates, outputSupplementalText);
		insert(sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end

	
///////// ***
// General Design rule... Do not Edit
///////// ***
rule "ProcessResults: Return Recommendations For Seasonal Series" ruleflow-group "ProcessResults"
	dialect "mvel"
	lock-on-active true
	salience 10
	when
		$ts : TargetSeries($vg : vaccineGroup, targetSeason != null, isSelectedSeries() == true, $tseasonStartDate : targetSeason.fullySpecifiedSeasonStartDate)
		not TargetSeries(vaccineGroup == $vg, targetSeason != null,	targetSeason.fullySpecifiedSeasonStartDate.isAfter($tseasonStartDate)) 
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputRootImmRecommendationSubstanceAdministrationProposal(drools, namedObjects, focalPersonId, iceVersion, $ts, outputEarliestOverdueDates, outputSupplementalText);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// START Supplemental Output Rules - Output Series Display Selection and Number of Doses Remaining for each Series Display Option
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////// ***
// General Design Rule... Do not Edit
// Output Series Selection display information if option enabled
///////// ***
rule "Series Display(Abstract): Return Series Selection Display Options" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 8
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType == SeriesDisplaySelectionType.SERIES_DISPLAY_NOT_SELECTED)
		$ts : TargetSeries(this == $ss.targetSeries, isSeriesComplete() == false && (recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE) || 
			isSeriesComplete() == true && determineEffectiveNumberOfDosesInSeries() <= seriesRules.numberOfDosesInSeries)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Selection \": " + $ts.seriesName);
end


///////// ***
// General Design Rule... Do not Edit
// Output Series Selection display information if option enabled
///////// ***
rule "Series Display: Mark Selected Series as Unambiguous for Display if there is only one configured series for the Vaccine Group"
		extends "Series Display(Abstract): Return Series Selection Display Options" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 8
	when
		accumulate($srthis : SeriesRules(vaccineGroup == $ts.vaccineGroup); $numberOfSeriesInVG : count($srthis); $numberOfSeriesInVG == 1)
		$sssame : SeriesDisplaySelection(this == $ss, seriesDisplaySelectionType == SeriesDisplaySelectionType.SERIES_DISPLAY_NOT_SELECTED)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($ss) {
			setSeriesDisplaySelectionType(SeriesDisplaySelectionType.SERIES_DISPLAY_UNAMBIGUOUS);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Selection \": " + $ts.seriesName + "; " + SeriesDisplaySelectionType.SERIES_DISPLAY_UNAMBIGUOUS);
end


///////// ***
// General Design Rule... Do not Edit
// Output Series Selection display information if option enabled
///////// ***
rule "Series Display: Mark Selected Series as Best Guess for Display when there are more than one configured series for the Vaccine Group" 
		extends "Series Display(Abstract): Return Series Selection Display Options" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 8
	when
		accumulate($srthis : SeriesRules(vaccineGroup == $ts.vaccineGroup); $numberOfSeriesInVG : count($srthis); $numberOfSeriesInVG > 1)
		$sssame : SeriesDisplaySelection(this == $ss, seriesDisplaySelectionType == SeriesDisplaySelectionType.SERIES_DISPLAY_NOT_SELECTED)
	then
		String _RULENAME = kcontext.rule.name;
		modify ($ss) {
			setSeriesDisplaySelectionType(SeriesDisplaySelectionType.SERIES_DISPLAY_BEST_GUESS);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Selection \": " + $ts.seriesName + "; " + SeriesDisplaySelectionType.SERIES_DISPLAY_BEST_GUESS);	
end


///////// ***
// General Design Rule... Do not Edit
// Output Series Selection display information if option enabled
///////// ***
rule "Series Display: Invoke Series Display Custom Rules" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 7
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ts : TargetSeries()
		exists SeriesDisplaySelection(targetSeries.vaccineGroup == $ts.vaccineGroup, targetSeries != $ts, seriesDisplaySelectionType == SeriesDisplaySelectionType.SERIES_DISPLAY_NOT_SELECTED)
		not SeriesDisplaySelection(targetSeries.vaccineGroup == $ts.vaccineGroup, seriesDisplaySelectionType == SeriesDisplaySelectionType.SERIES_DISPLAY_UNAMBIGUOUS)
	then
		String _RULENAME = kcontext.rule.name;
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Invoking custom series display logic for vaccine group: " + $ts.vaccineGroup);
		setFocus("ProcessResults^customSeriesDisplayLogic");
end


///////// ***
// General Design Rule... Do not Edit
// Output Series Selection display information if option enabled
///////// ***
rule "Series Display: For any remaining series display selections set to SERIES_DISPLAY_NOT_SELECTED, change the series display selection to SERIES_DISPLAY_NONE" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 6
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType == SeriesDisplaySelectionType.SERIES_DISPLAY_NOT_SELECTED)
	then
		String _RULENAME = kcontext.rule.name;
		modify($ss) {
			setSeriesDisplaySelectionType(SeriesDisplaySelectionType.SERIES_DISPLAY_NONE);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Display Selection changed to SERIES_DISPLAY_NONE for: " + $ss);
end


///////// ***
// General Design Rule... Do not Edit
// Output Series Selection display information if option enabled
///////// ***
rule "Series Display: Set Number of Doses Remaining to Recommendation for a Series that is Not Complete" ruleflow-group "ProcessResults"
	dialect "mvel"
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType != SeriesDisplaySelectionType.SERIES_DISPLAY_NONE, isSeriesDisplaySelectionDeterminationComplete() == false, $numberOfDosesInSeries : targetSeries.seriesRules.numberOfDosesInSeries, $numberOfDosesAdministered : targetSeries.determineEffectiveNumberOfDosesInSeries())
		not ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.getConceptCodeValue(), associatedTargetSeries == $ss.targetSeries)
		$tssamevg : TargetSeries(vaccineGroup == $ss.vaccineGroup, isSeriesComplete() == false, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE)
	then
		String _RULENAME = kcontext.rule.name;
		int lNumberRemaining = $numberOfDosesInSeries - $numberOfDosesAdministered;
		String lStrNumberRemaining = String.valueOf(lNumberRemaining);
		modify($ss) {
			setNumberOfDosesRemaining(lStrNumberRemaining),
			setSeriesDisplaySelectionDeterminationComplete(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ss.getTargetSeries().getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);
end


///////// ***
// Supplemental Output rule... Output Zero Doses Remaining to Recommendation for a Series that is Not Recurring and Complete; however, one or more additional doses may be recommended
///////// ***
rule "Series Display: Set Number of Doses Remaining to Zero Doses for a Series that is Not Recurring and Complete; \"however, one or more additional doses may still be recommended\"" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType != SeriesDisplaySelectionType.SERIES_DISPLAY_NONE, isSeriesDisplaySelectionDeterminationComplete() == false)
		$tssamevg : TargetSeries(vaccineGroup == $ss.vaccineGroup, isSeriesComplete() == true, getSeriesRules().recurringDosesOccurAfterSeriesComplete() == false, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "0 doses remaining in series; one or more additional doses may still be recommended"
		modify($ss) {
			setNumberOfDosesRemaining(lStrNumberRemaining),
			setSeriesDisplaySelectionDeterminationComplete(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ss.getTargetSeries().getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);	
end


///////// ***
// Supplemental Output rule... Output Zero Doses Remaining to Recommendation for a Series that is Not Recurring and Complete
///////// ***
rule "Series Display: Set Number of Doses Remaining to Zero Doses for a Series that is Not Recurring and Complete" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType != SeriesDisplaySelectionType.SERIES_DISPLAY_NONE, isSeriesDisplaySelectionDeterminationComplete() == false)
		$tssamevg : TargetSeries(vaccineGroup == $ss.vaccineGroup, isSeriesComplete() == true, getSeriesRules().recurringDosesOccurAfterSeriesComplete() == false, recommendationStatus != RecommendationStatus.RECOMMENDED && recommendationStatus != RecommendationStatus.RECOMMENDED_IN_FUTURE)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "0"
		modify($ss) {
			setNumberOfDosesRemaining(lStrNumberRemaining),
			setSeriesDisplaySelectionDeterminationComplete(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ss.getTargetSeries().getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);	
end


///////// ***
// Supplemental Output rule... Output doses N/A for Doses Remaining to Recommendation for a Series that is Recurring
///////// ***
rule "Series Display: Set Number of Doses Remaining to  \"Recurring\" for a Series that is Complete and Recurring" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType != SeriesDisplaySelectionType.SERIES_DISPLAY_NONE, isSeriesDisplaySelectionDeterminationComplete() == false)
		$tssamevg : TargetSeries(vaccineGroup == $ss.vaccineGroup, isSeriesComplete() == true, getSeriesRules().recurringDosesOccurAfterSeriesComplete() == true, recommendationStatus == RecommendationStatus.RECOMMENDED || recommendationStatus == RecommendationStatus.RECOMMENDED_IN_FUTURE)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "Recurring";
		modify($ss) {
			setNumberOfDosesRemaining(lStrNumberRemaining),
			setSeriesDisplaySelectionDeterminationComplete(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ss.getTargetSeries().getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);
end


///////// ***
// Supplemental Output rule... Output doses N/A for Doses Remaining to Recommendation for a Series that is Not Recommended
///////// ***
rule "Series Display: Append N/A for Doses Remaining to Recommendation for a Series that is Not Recommended" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 5
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ss : SeriesDisplaySelection(seriesDisplaySelectionType != SeriesDisplaySelectionType.SERIES_DISPLAY_NONE, isSeriesDisplaySelectionDeterminationComplete() == false)
		$tssamevg : TargetSeries(vaccineGroup == $ss.vaccineGroup, recommendationStatus == RecommendationStatus.NOT_RECOMMENDED)
	then
		String _RULENAME = kcontext.rule.name;
		String lStrNumberRemaining = "0";
		modify($ss) {
			setNumberOfDosesRemaining(lStrNumberRemaining),
			setSeriesDisplaySelectionDeterminationComplete(true);
		}
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Doses remaining for series \"" + $ss.getTargetSeries().getSeriesRules().getSeriesName() + "\": " + lStrNumberRemaining);
end


///////// ***
// Supplemental Output rule... Output Series Display Selections and Number of Doses Remaining for each
///////// ***
rule "Series Display: Output Series Display Selections and Number of Doses Remaining for Each Vaccine Group" ruleflow-group "ProcessResults"
	dialect "mvel"
	no-loop true
	salience 3
	when
		exists (ICEFactTypeFinding(iceResultFinding == SupportedFactConcept._OUTPUT_NUMBER_OF_DOSES_REMAINING.conceptCodeValue))
		$ts : TargetSeries()
		$sap : SubstanceAdministrationProposal(id == $ts.targetSeriesIdentifier)	// AI: Fix leak
		$sdlist : List() from 
			accumulate($sdthis : SeriesDisplaySelection(targetSeries.vaccineGroup == $ts.vaccineGroup, seriesDisplaySelectionType != SeriesDisplaySelectionType.SERIES_DISPLAY_NONE, isSeriesDisplaySelectionDeterminationComplete() == true), collectList($sdthis));
		
	then
		String _RULENAME = kcontext.rule.name;
		PayloadHelper p = new PayloadHelper(schedule);
		p.OutputSeriesDisplaySelectionsAndDosesRemainingInEmbeddedSubstanceAdministrationProposals(drools, namedObjects, focalPersonId, $sdlist, $sap);
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Series Display Selection \": " + $ts.seriesName);
end


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// END -- Supplemental Output Rules - Output Series Display Selection and Number of Doses Remaining for each Series Display Option
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set flag to be returned for all Entities and ClinicalStatements START
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////// ***
// General Design rule... Do not Edit
///////// ***
rule "BounceAllEntities" ruleflow-group "ProcessResults"
	dialect "mvel"
	when
		$entityBase : EntityBase( toBeReturned == false )
	then
		String _RULENAME = kcontext.rule.name;
		$entityBase.setToBeReturned( true );
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end


///////// ***
// General Design rule... Do not Edit
///////// ***
rule "BounceAllClinicalStatements" ruleflow-group "ProcessResults"
	dialect "mvel"
	when
		$cs : ClinicalStatement( toBeReturned == false )
	then
		String _RULENAME = kcontext.rule.name;
		$cs.setToBeReturned( true );
		ICELogicHelper.logDRLDebugMessage(_RULENAME, "Results processing");	
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set flag to be returned for all Entities and ClinicalStatements END
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//NOTE:  all demographics about the Patient are always returned in the result 
//			when the result is an outputVMR.

//NOTE2:  all ClinicalStatements, except ObservationResults are always returned as root elements

//NOTE3:  all Entities that have a relationship to a ClinicalStatement or to another Entity 
//			are always returned nested within that ClinicalStatement or Entity ONLY if that
//			ClinicalStatement or Entity is flagged toBeReturned.  

//NOTE4:  all Entities that are related directly to the patient will be returned or not
//			depending on the setting of the toBeReturned flag.



